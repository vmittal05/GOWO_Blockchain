{-# LANGUAGE LambdaCase #-}
-- |
-- Module     : Main
-- Copyright  : Copyright (c) 2017-2018 DFINITY Stiftung. All rights reserved.
-- License    : GPL-3
-- Maintainer : Enzo Haussecker <enzo@dfinity.org>
-- Stability  : Stable
--
-- Demonstrate bidirectional interprocess communication.
module Main where

import Control.Concurrent.MVar       (tryTakeMVar)
import Control.Concurrent.STM.TQueue (readTQueue, writeTQueue)
import Control.Monad.IO.Class        (liftIO)
import Control.Monad.STM             (atomically)
import Control.Monad.Trans.Resource  (runResourceT)
import Data.Word                     (Word16)
import System.Directory              (doesFileExist)
import System.Exit                   (ExitCode(..), exitWith)
import Test.HUnit                    (Counts(..), Test(..), (@=?), runTestTT)

import Network.DFINITY.Process
import Paths_dfinity (getDataFileName)

db :: String
db = "./echodb"

proto :: String
proto = "tcp"

ip :: String
ip = "127.0.0.1"

port :: Word16
port = 3246

process :: String
process = "src/javascript/bin/echo"

test :: IO Test
test = do
  process' <- getDataFileName process
  process_path <- doesFileExist process' >>= \case
    True -> return process'
    False -> return process
  m'in <- runResourceT $ do
    queue <- runProcess process_path db proto ip port
    liftIO $ tryTakeMVar queue >>= maybe (return ("","")) (atomically . run) 
  pure $ TestCase $ m'out @=? m'in
  where 
    run ProcessQueue{..} = writeTQueue processOutbound m'out >> readTQueue processInbound
    m'out = (,) "subject" "body"

main :: IO ()
main = do
  Counts {..} <- runTestTT =<< test
  exitWith $ case failures + errors of
    0 -> ExitSuccess
    _ -> ExitFailure 1
