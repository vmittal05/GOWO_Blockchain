module Network.DFINITY.P2P.Types
   ( AddressBook
   , ArtifactCache
   , Command(..)
   , Config(..)
   , Epoch
   , Error(..)
   , HasStatus(..)
   , Interface(..)
   , Node(..)
   , NodeAddr(..)
   , NodeId(..)
   , Predecessor(..)
   , Status(..)
   , Successor(..)
   , WitnessCache
   ) where

import Control.Concurrent (ThreadId)
import Control.Concurrent.STM.TBQueue (TBQueue)
import Control.Concurrent.STM.TQueue (TQueue)
import Control.Concurrent.STM.TVar (TVar)
import Control.DeepSeq (NFData)
import Control.Exception (Exception)
import Control.Monad ((>=>), mzero)
import Data.Aeson as JSON (FromJSON(..), FromJSONKey(..), FromJSONKeyFunction(..), ToJSON(..), ToJSONKey(..), ToJSONKeyFunction(..), Value(..), eitherDecode, encode)
import Data.Aeson.Encoding.Internal (text)
import Data.ByteString.Base64 as Base64 (encode)
import Data.ByteString.Char8 as Byte (ByteString, break, length, snoc, splitAt, tail, unpack)
import Data.ByteString.Lazy.Char8 (fromStrict, toStrict)
import Data.ByteString.Short (ShortByteString)
import Data.LruCache (LruCache)
import Data.Map.Strict (Map)
import Data.Text (Text)
import Data.Typeable (Typeable)
import Data.Word (Word32)
import GHC.Generics (Generic)
import Network (HostName, PortNumber)
import Network.Kademlia (KademliaInstance, KademliaSnapshot, Serialize(..))
import Network.Socket (Socket)
import Network.TLS (Context, ServerParams)
import System.IO (Handle)

import Network.DFINITY.Orphan ()

type AddressBook = KademliaInstance NodeId NodeAddr

type ArtifactCache = TVar (LruCache ShortByteString ())

data Command
   = Configure [NodeId]
   | Rotate
   | Setup Epoch [NodeId] [NodeId]

data Config
   = Config
   { _cfgArtifactCacheSize :: Int
   , _cfgBucketSize :: Int
   , _cfgController :: TQueue Command
   , _cfgDebug :: String -> IO ()
   , _cfgError :: String -> IO ()
   , _cfgExternIP :: HostName
   , _cfgExternTCPPort :: PortNumber
   , _cfgExternUDPPort :: PortNumber
   , _cfgInternIP :: HostName
   , _cfgInternTCPPort :: PortNumber
   , _cfgInternUDPPort :: PortNumber
   , _cfgNodeId :: NodeId
   , _cfgSeedNodes :: [NodeAddr]
   , _cfgServerParams :: ServerParams
   , _cfgSnapshot :: Maybe (KademliaSnapshot NodeId)
   , _cfgWitnessCacheSize :: Int
   }

type Epoch = Word32

data Error
   = Error String
   deriving (Show, Typeable)

instance Exception Error

class HasStatus x where
   getStatus :: x -> Status

data Interface
   = Interface
   { _p2pAddressBook :: AddressBook
   , _p2pAddresses :: [String]
   , _p2pArtifactCache :: ArtifactCache
   , _p2pBuckets :: TVar [NodeId]
   , _p2pDispatcher :: ThreadId
   , _p2pEpoch :: TVar Epoch
   , _p2pPredecessors :: TVar (Map Epoch [Predecessor])
   , _p2pReceive :: TBQueue (ByteString, NodeId)
   , _p2pSend :: TQueue ByteString
   , _p2pServer :: ThreadId
   , _p2pSocket :: Socket
   , _p2pSuccessors :: TVar (Map Epoch [Successor])
   , _p2pWhitelist :: TVar [[NodeId]]
   , _p2pWitnessCache :: WitnessCache
   }

data Node
   = Node
   { _nodeId :: NodeId
   , _nodeAddr :: NodeAddr
   } deriving (Eq, Generic, Ord, Typeable)

instance FromJSON Node

instance Show Node where
   show Node {..} = show _nodeId ++ '@' : show _nodeAddr

data NodeAddr
   = NodeAddr
   { _nodeHost :: HostName
   , _nodePort :: PortNumber
   } deriving (Eq, Generic, Ord, Typeable)

-- TODO (enzo): Check if the hostname is really an IP address.
instance FromJSON NodeAddr

instance Serialize NodeAddr where
   toBS = flip snoc '\NUL' . toStrict . JSON.encode
   fromBS input = (,leftover) <$> eitherDecode bytes
      where (fromStrict -> bytes, Byte.tail -> leftover) = Byte.break ((==) '\NUL') input

instance Show NodeAddr where
   show NodeAddr {..} = _nodeHost ++ ':' : show _nodePort

instance ToJSON NodeAddr

toText :: NodeId -> Text
toText = flip (.) toJSON $ \ case
   String t -> t
   v -> error $ "impossible value: " ++ show v

newtype NodeId = NodeId { getNodeId :: ByteString }
   deriving (Eq, Generic, Ord, Typeable, NFData)

instance FromJSON NodeId where
   parseJSON = parseJSON >=> \ bytes ->
      if Byte.length bytes == 32
      then pure $ NodeId bytes
      else mzero

instance FromJSONKey NodeId where
   fromJSONKey = FromJSONKeyTextParser $ parseJSON . String

instance Serialize NodeId where
   toBS = getNodeId
   fromBS input =
      if Byte.length bytes == 32
      then Right (NodeId bytes, leftover)
      else Left $ "invalid network identifier: " ++ show bytes
      where (bytes, leftover) = Byte.splitAt 32 input

instance Show NodeId where
   show = unpack . Base64.encode . getNodeId

instance ToJSON NodeId where
   toJSON = toJSON . getNodeId

instance ToJSONKey NodeId where
   toJSONKey = ToJSONKeyText toText $ text . toText

data Predecessor
   = Predecessor
   { _predContext :: Context
   , _predHandle :: Handle
   , _predNodeId :: NodeId
   , _predStatus :: Status
   , _predThreadId :: ThreadId
   }

instance Eq Predecessor where
   a == b = _predNodeId a == _predNodeId b

instance Show Predecessor where
   show Predecessor {..} = show _predNodeId

instance HasStatus Predecessor where
   getStatus = _predStatus

data Status
   = Offline
   | Online
   deriving (Eq, Ord, Show)

data Successor
   = Successor
   { _succNodeId :: NodeId
   , _succThreadId :: ThreadId
   , _succStatus :: Status
   , _succSendQueue :: TBQueue ByteString
   }

instance Eq Successor where
   a == b = _succNodeId a == _succNodeId b

instance HasStatus Successor where
   getStatus = _succStatus

instance Show Successor where
   show Successor {..} = show _succNodeId

type WitnessCache = TVar (LruCache ShortByteString [NodeId])
