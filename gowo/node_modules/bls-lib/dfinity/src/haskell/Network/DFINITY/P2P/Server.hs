module Network.DFINITY.P2P.Server where

import Control.Concurrent (forkIO, killThread)
import Control.Concurrent.STM.TBQueue (TBQueue)
import Control.Concurrent.STM.TVar (TVar, modifyTVar, readTVar)
import Control.Exception (finally, try)
import Control.Monad (forever)
import Control.Monad.STM (atomically)
import Data.ByteString.Char8 (ByteString)
import Data.Map.Strict as Map (Map, insert, lookup)
import Network.Socket as Socket (Socket, accept, socketToHandle)
import Network.TLS (ServerParams, TLSException, contextClose, contextNew, handshake)
import System.IO (IOMode(..), hClose)
import System.Timeout (timeout)

import Network.DFINITY.P2P.Connection (connRead, connReadCredentials, connProcess)
import Network.DFINITY.P2P.Types (ArtifactCache, Epoch, NodeId, Predecessor(..), Status(..), WitnessCache)

-- |
-- Run the TLS server.
runServer
   :: ServerParams
   -> Socket
   -> TVar (Map Epoch [Predecessor])
   -> TBQueue (ByteString, NodeId)
   -> ArtifactCache
   -> WitnessCache
   -> TVar [[NodeId]]
   -> IO ()
runServer params connection peers receive artifacts witnesses whitelist =
   forever $ do
      sockId <- fst <$> accept connection
      forkIO $ do
         handle <- socketToHandle sockId ReadWriteMode
         context <- contextNew handle params
         -- TODO: Add DDoS protection here.
         protocol <- try $ timeout 10000000 $ handshake context >> connRead context 1 Nothing
         case protocol :: _ TLSException _ of
            Right (Just ("0", residue)) -> do
               credentials <- try $ timeout 10000000 $ connReadCredentials context $ Just residue
               case credentials :: _ TLSException _ of
                  Right (Just (epoch, nodeId, residue')) -> do
                     -- TODO: Check if the node is really a predecessor.
                     threadId <- forkIO $ do
                        let process = connProcess context nodeId receive artifacts witnesses $ Just residue'
                        finally process $ do
                           -- TODO: Update predecessor status to offline.
                           return ()
                     let peer = Predecessor context handle nodeId Online threadId
                     upsertPredecessor epoch peer peers
                  err -> do
                     -- TODO: Report the timeout or error.
                     print err
                     contextClose context
                     hClose handle
            Right (Just ("1", residue)) -> do
               -- TODO: Service the sync request.
               contextClose context
               hClose handle
            err -> do
               -- TODO: Report the unsupported protocol or error.
               print err
               contextClose context
               hClose handle

upsertPredecessor
   :: Epoch
   -> Predecessor
   -> TVar (Map Epoch [Predecessor])
   -> IO ()
upsertPredecessor epoch p storage = do
   mval <- atomically $ do
      cache <- readTVar storage
      case Map.lookup epoch cache of
         Nothing -> do
            replaceWith [p]
            pure Nothing
         Just ps ->
            case break ((==) p) ps of
               (_, []) -> do
                  replaceWith $ p:ps
                  pure Nothing
               (ls, Predecessor {..}:rs) -> do
                  replaceWith $ ls ++ p:rs
                  pure $ Just (_predThreadId, _predContext, _predHandle)
   case mval of
      Nothing -> pure ()
      Just (threadId, context, handle) -> do
         killThread threadId
         contextClose context
         hClose handle
   where
   replaceWith contexts = modifyTVar storage $ Map.insert epoch contexts
