module Network.DFINITY.P2P.TLS
   ( tlsClientParams
   , tlsServerParams
   ) where

import Data.ByteString.Char8 (pack)
import Data.Default.Class (def)
import Network.TLS 
import Network.TLS.Extra.Cipher

import Network.DFINITY.P2P.Types (NodeAddr(..))

tlsClientParams :: NodeAddr -> ClientParams
tlsClientParams NodeAddr {..} = (defaultParamsClient _nodeHost $ pack $ show _nodePort)
    { clientSupported  = supported
    , clientShared     = def { sharedValidationCache = noValidate      }
    }
    where
    noValidate = ValidationCache (\_ _ _ -> return ValidationCachePass) -- This is not secure!
                                 (\_ _ _ -> return ())
    supported = def {
        supportedVersions       = [TLS12]
      , supportedCiphers        = ciphersuite_strong
      , supportedCompressions   = [nullCompression]
      , supportedSecureRenegotiation = True
      , supportedClientInitiatedRenegotiation = False
      , supportedSession             = True
      , supportedFallbackScsv        = True
      }

tlsServerParams :: FilePath -> FilePath -> IO ServerParams
tlsServerParams keyFile  certFile = do
    cred <- either error id <$> credentialLoadX509 certFile keyFile


    pure $ params cred
    where
    params cred = def {
        serverWantClientCert = False
      , serverCACertificates = []
      , serverDHEParams      = Nothing
      , serverHooks          = def
      , serverShared         = def { sharedCredentials = Credentials [cred] }
      , serverSupported      = supported
      }
    supported = def {
        supportedVersions       = [TLS12]
      , supportedCiphers        = ciphersuite_strong
      , supportedCompressions   = [nullCompression]
      , supportedSecureRenegotiation = True
      , supportedClientInitiatedRenegotiation = False
      , supportedSession             = True
      , supportedFallbackScsv        = True
      }
