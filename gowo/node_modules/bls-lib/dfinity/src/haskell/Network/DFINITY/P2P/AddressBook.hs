module Network.DFINITY.P2P.AddressBook
   ( createAddressBook
   , destroyAddressBook
   , getAddress
   , putAddress
   , shareAddressBook
   ) where

import Control.Concurrent (threadDelay)
import Control.Exception (throw)
import Network.Kademlia as DHT (JoinResult(..), Peer(..), close, createL, createLFromSnapshot, defaultConfig, joinNetwork, lookup, store)

import Network.DFINITY.P2P.Types

-- |
-- Create an address book.
createAddressBook :: Config -> IO AddressBook
createAddressBook Config {..} =
   case _cfgSnapshot of
      Nothing -> createL intern extern _cfgNodeId defaultConfig _cfgDebug _cfgError
      Just snapshot -> createLFromSnapshot intern extern defaultConfig snapshot _cfgDebug _cfgError
   where
   intern = (_cfgInternIP, fromIntegral _cfgInternUDPPort)
   extern = (_cfgExternIP, fromIntegral _cfgExternUDPPort)

-- |
-- Release all resources associated with an address book.
destroyAddressBook :: AddressBook -> IO ()
destroyAddressBook = close

-- |
-- Share an address book with a network.
shareAddressBook :: AddressBook -> [NodeAddr] -> IO ()
shareAddressBook book network = do
   results <- flip mapM network $ \ NodeAddr {..} ->
      joinNetwork book $ Peer _nodeHost _nodePort
   if null network || any (==JoinSuccess) results
   then pure ()
   else throw $ Error "cannot connect to network"

-- |
-- Read an address from an address book. This will block until the address
-- becomes available.
getAddress :: AddressBook -> NodeId -> IO NodeAddr
getAddress book nodeId =
   go 1000000 where
   go n = do
      mval <- DHT.lookup book nodeId
      case mval of
         Just (address, _) -> pure address
         Nothing -> do
            threadDelay n
            go $ min 64000000 $ 2 * n

-- |
-- Write an address to an address book.
putAddress :: AddressBook -> NodeId -> NodeAddr -> IO ()
putAddress = store
