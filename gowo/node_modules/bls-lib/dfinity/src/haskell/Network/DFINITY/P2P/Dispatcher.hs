module Network.DFINITY.P2P.Dispatcher where

import Control.Concurrent (forkIO, threadDelay)
import Control.Concurrent.Async (forConcurrently)
import Control.Concurrent.STM.TBQueue (newTBQueueIO, readTBQueue)
import Control.Concurrent.STM.TQueue (TQueue, readTQueue)
import Control.Concurrent.STM.TVar (TVar, modifyTVar, readTVar)
import Control.Exception (SomeException, bracket, catch, onException)
import Control.Monad (forever, when)
import Control.Monad.STM (atomically)
import Data.Map as Map (Map, insert, lookup)
import Network.Socket (Family(..), SocketType(..), close, connect, socket, socketToHandle)
import Network.TLS (contextClose, contextFlush, contextNew, handshake)
import System.IO (IOMode(..), hClose)

import Network.DFINITY.P2P.AddressBook (getAddress)
import Network.DFINITY.P2P.Connection (connWrite, connWriteArtifact, connWriteCredentials)
import Network.DFINITY.P2P.TLS (tlsClientParams)
import Network.DFINITY.P2P.Types (AddressBook, Command(..), Epoch, NodeId, Status(..), Successor(..))
import Network.DFINITY.P2P.Utilities (convert)


-- |
-- Run the dispatcher. This will processes messages from the consensus layer and
-- rotate connections accordingly.
runDispatcher
   :: AddressBook
   -> TVar [NodeId]
   -> TQueue Command
   -> TVar Epoch
   -> NodeId
   -> TVar (Map Epoch [Successor])
   -> TVar [[NodeId]]
   -> IO ()
runDispatcher addressBook buckets controller epoch nodeId successors whitelist =
   loop where
   loop = do
      command <- atomically $ readTQueue controller
      case command of
         Configure nodeIds -> do
            atomically $ modifyTVar buckets $ const nodeIds
            loop
         Setup nextEpoch predIds succIds -> do
            peers <- forConcurrently succIds $ \ succId -> do
               outbound <- newTBQueueIO 256
               threadId <- forkIO $ do
                  nodeAddr <- getAddress addressBook succId
                  sockAddr <- convert nodeAddr
                  forever $ (do
                     sockId <- socket AF_INET Stream 0
                     connect sockId sockAddr `onException` close sockId
                     hdl <- socketToHandle sockId ReadWriteMode
                     let params = tlsClientParams nodeAddr
                     ctx <- contextNew hdl params
                     bracket (pure hdl) hClose $ \ _ -> do
                        bracket (pure ctx) contextClose $ \ ctx -> do
                           handshake ctx
                           updateSuccessorStatus nextEpoch succId Online successors
                           connWrite ctx "0"
                           connWriteCredentials ctx nextEpoch nodeId
                           contextFlush ctx
                           forever $ do
                              artifact <- atomically $ readTBQueue outbound
                              connWriteArtifact ctx artifact)
                     `catch` (\e -> print (e :: SomeException)) -- also update status to offline, delay retry
               pure $ Successor succId threadId Offline outbound
            atomically $ modifyTVar successors $ Map.insert nextEpoch peers
            atomically $ modifyTVar whitelist $ take 3 . (:) predIds
            loop
         Rotate -> do
            -- TODO: Increment the epoch and destroy obsolete peer contexts.
            loop

updateSuccessorStatus
   :: Epoch
   -> NodeId
   -> Status
   -> TVar (Map Epoch [Successor])
   -> IO ()
updateSuccessorStatus epoch nodeId status storage = do
   retry <- atomically $ do
      cache <- readTVar storage
      case Map.lookup epoch cache of
         Nothing -> pure True
         Just ps ->
            case break ((==) nodeId . _succNodeId) ps of
               (_, []) -> pure True
               (ls, Successor {..}:rs) -> do
                  let p = Successor _succNodeId _succThreadId status _succSendQueue
                  modifyTVar storage $ Map.insert epoch (ls ++ p:rs)
                  pure False
   when retry $ do
      threadDelay 100000
      updateSuccessorStatus epoch nodeId status storage
