module Network.DFINITY.Config
  ( Config(..)
  , runConfigT
  ) where

import Control.Concurrent.MVar        (MVar)
import Control.Concurrent.STM.TChan   (TChan)
import Control.Concurrent.STM.TQueue  (TQueue)
import Control.Concurrent.STM.TVar    (TVar)
import Control.Monad.Reader           (ReaderT(..))
import Crypto.Secp256k1               (SecKey, PubKey)
import Data.Int                       (Int64)
import Database.LevelDB.MonadResource (DB)
import System.Logger                  (Logger)

import Network.DFINITY.Artifact
import Network.DFINITY.Bootstrap
import Network.DFINITY.Consensus
import Network.DFINITY.Message
import Network.DFINITY.Metric
import Network.DFINITY.P2P.Types hiding (Config)
import Network.DFINITY.Process
import Network.DFINITY.Transaction

data Config =
  Config
  { cfgAddresses        :: [String]
  , cfgArtifactInbound  :: TChan (Int64, Artifact (NotarizedBlock Transactions))
  , cfgArtifactOutbound :: TQueue Message
  , cfgDatabase         :: MVar DB
  , cfgInterface        :: Interface
  , cfgLogger           :: Logger
  , cfgMetrics          :: TQueue Metric
  , cfgPrimea           :: MVar ProcessQueue 
  , cfgPublicKey        :: PubKey
  , cfgReady            :: MVar ()
  , cfgRegistry         :: TVar (Bool, [(NodeId, PubKey)])
  , cfgSecretKey        :: SecKey
  , cfgKeyFrame         :: MVar (Maybe GenesisKeyFrame)
  }

runConfigT
  :: Monad m
  => Config
  -> ReaderT Config m a
  -> m a
runConfigT = flip runReaderT
