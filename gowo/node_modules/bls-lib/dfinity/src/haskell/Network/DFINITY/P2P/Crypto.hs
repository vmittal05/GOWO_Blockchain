module Network.DFINITY.P2P.Crypto
   ( deriveNodeId
   , deriveKautz
   ) where

import Crypto.Secp256k1 (SecKey)
import Data.Hashable (Hashable, hash)
import Data.List (delete, findIndex)
import System.Random (mkStdGen)
import System.Random.Shuffle (shuffle')

import Network.DFINITY.P2P.Kautz
import Network.DFINITY.P2P.Types
import Network.DFINITY.Consensus

-- |
-- Derive a node ID from a Secp256k1 secret key. 
deriveNodeId :: SecKey -> NodeId
deriveNodeId secKey = 
   NodeId $ hashBytes $ hash256 $ secKey

-- |
-- Derive the direct predecessors and successors for a given node, its network,
-- and the random beacon. 
deriveKautz :: Hashable a => NodeId -> [NodeId] -> a -> ([NodeId], [NodeId])
deriveKautz nodeId network seed = if
   | size < 10 -> (everyone, everyone)
   | otherwise -> (predecessors, successors)
   where
   size = length network
   everyone = delete nodeId network
   predecessors  = kautz kautzInRoomy
   successors = kautz kautzOutRoomy
   kautz f = map (network'!!) $ f m n i size
   network' = shuffle' network size $ mkStdGen $ hash seed
   (m, n) = kautzRecommend $ size
   i = maybe err id $ findIndex (==nodeId) network'
   err = error "does not exist"
