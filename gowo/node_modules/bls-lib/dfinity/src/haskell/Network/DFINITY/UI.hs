module Network.DFINITY.UI (runUI) where

import Codec.Serialise                     (Serialise, serialise, deserialise)
import Control.Concurrent.Async            (async, link)
import Control.Concurrent.MVar             (putMVar, tryReadMVar)
import Control.Concurrent.STM.TChan        (TChan, dupTChan, readTChan)
import Control.Concurrent.STM.TQueue       (writeTQueue)
import Control.Concurrent.STM.TVar         (modifyTVar, readTVar, writeTVar)
import Control.Concurrent                  (threadDelay, forkIO)
import Control.DeepSeq                     (force)
import Control.Monad                       ((<=<), void)
import Control.Monad.Base                  (MonadBase(..))
import Control.Monad.IO.Class              (MonadIO)
import Control.Monad.Reader                (MonadReader(..))
import Control.Monad.STM                   (atomically)
import Control.Monad.Trans                 (lift)
import Control.Monad.Trans.Control         (MonadBaseControl)
import Control.Monad.Trans.Resource        (ResourceT, runResourceT, resourceForkWith, MonadThrow(..))
import Crypto.BLS                          (Signature)
import Data.Aeson                          (FromJSON(..), ToJSON(..), Value(..), (.=), object)
import Data.Binary.Builder                 (fromLazyByteString)
import Data.ByteString.Char8               (pack)
import Data.ByteString.Lazy                (fromStrict)
import Data.ByteString.Base64.Lazy         (encode)
import Data.Function                       (fix)
import Data.Int                            (Int64)
import Data.List                           (nub)
import Data.Monoid                         ((<>))
import Data.Text.Lazy                      (Text)
import Data.Word                           (Word16)
import GHC.Generics                        (Generic)
import Network.HTTP.Types.Status           (status400, status403)
import Network.Wai                         (StreamingBody)
import Network.Wai.EventSource.EventStream (ServerEvent(..), eventToBuilder)
import Network.Wai.Handler.Warp            (defaultSettings, setPort)
import Prelude hiding                      (log)
import Web.Scotty.Trans                    (ActionT, Options(..), ScottyError, ScottyT, get, raw, rescue, param, json, jsonData, post, request, scottyOptsT, setHeader, status, stream)

import qualified Data.Vector as V

import Network.DFINITY.Artifact
import Network.DFINITY.Bootstrap
import Network.DFINITY.Database
import Network.DFINITY.Consensus hiding (Signature, Epoch)
import Network.DFINITY.Message
import Network.DFINITY.Config
import Network.DFINITY.Log
import Network.DFINITY.P2P
import Network.DFINITY.P2P.Types (Epoch)
import Network.DFINITY.Register
import Network.DFINITY.Transaction

data GroupSetup
   = GroupSetup
   { groupCount :: Int
   , groupSize  :: Int
   } deriving (Generic, Show)

instance FromJSON GroupSetup

instance (ScottyError e, MonadThrow m) => MonadThrow (ActionT e m) where
  throwM = lift . throwM

runUI
  :: MonadBaseControl IO m
  => MonadReader Config m
  => MonadIO m
  => Word16
  -> ResourceT m ()
runUI port = do
  config <- runConfigT <$> ask
  resourceForkWith fork $ scottyOptsT opts config app
  Config {..} <- ask
  liftBase $ putMVar cfgReady ()
  where fork = link <=< async
        opts = Options 0 $ flip setPort defaultSettings $ fromIntegral port

app
  :: MonadBase IO m
  => MonadBaseControl IO m
  => MonadThrow m
  => MonadReader Config m
  => MonadIO m
  => ScottyT Text m ()
app = do

  get "/addresses" $ log $ do
    Config {..} <- ask
    json $ cfgAddresses

  get "/artifacts" $ log $ do
    Config {..} <- ask
    blocks <- liftBase $ atomically $ dupTChan cfgArtifactInbound
    setHeader "Cache-Control" "no-cache"
    setHeader "Content-Type" "text/event-stream"
    setHeader "X-Accel-Buffering" "no"
    stream $ events blocks

  get "/keyframe" $ log $ do
    Config {..} <- ask
    keyFrame <- liftBase $ tryReadMVar cfgKeyFrame
    maybe (return ()) (maybe (return ()) json) keyFrame

  get "/getblock" $ log $ do
    Config {..} <- ask
    h <- rescue (param "height") (\_ -> runResourceT (maybe 0 (deserialise . fromStrict) <$> getDB "height"))
    (blk, ts) <- runResourceT $ 
      getDB ("block." <> pack (show (h::Height))) >>= \case
        Nothing -> return (Nothing, Nothing)
        Just hash -> (,) <$> lookupHashed256 (Hash256 hash) <*> getDB ("timestamp." <> hash)
    let ts' = maybe 0 (deserialise . fromStrict) ts :: Int64
        sendit s = (raw . encode . serialise . (ts',) . toArtifact . unhashed) (s :: HashedBlock Transactions)
    maybe (return ()) sendit blk

  get "/api/v1/registry" $ log $ do
    Config {..} <- ask
    miners <- liftBase $ atomically $ do
      (,) lock entries <- readTVar cfgRegistry
      if not lock
      then pure Nothing
      else do
        -- TODO (enzo): What epoch is it?
        let beacon = "12345678123456781234567812345678" :: Signature
        let epoch = 0 :: Epoch
        pure $ Just (beacon, epoch, map fst entries)
    json miners

  get "/streams" $ log $ do
    Config {..} <- ask
    count <- liftBase $ p2pStreams cfgInterface
    json count

  post "/api/v1/genesis" $ log $ do
    Config {..} <- ask
    setup@GroupSetup {..} <- jsonData
    writeLogString Debug $ show setup
    if groupCount < 1 || groupSize < 1
    then do
      status status400
      let err = "non-positive group count or group size"
      json $ object ["error" .= String err]
    else do
      result <- liftBase $ atomically $ do
        registry <- snd <$> readTVar cfgRegistry
        if length registry < groupSize
        then pure $ Left "group size exceeds registrations"
        else do
          writeTVar cfgRegistry (True, registry)
          let step x = V.cons $ snd x
          pure $ Right $ foldr step V.empty registry
      case result of
        Left err -> do
          status status400
          json $ object ["error" .= String err]
        Right publicKeys -> liftBase $ do
          genesis <- createGenesis cfgLogger cfgPrimea publicKeys groupCount groupSize
          void $ forkIO $ do
            threadDelay 30000000
            atomically $ writeTQueue cfgArtifactOutbound $ toMessage $ NewGenesis genesis

  post "/message" $ log $ do
    Config {..} <- ask
    msg <- jsonData
    writeLogString Debug $ show msg
    liftBase $ atomically $ writeTQueue cfgArtifactOutbound $ force msg

  post "/submit" $ log $ do
    Config {..} <- ask
    txn <- (fromArtifact . deserialise . fromStrict) <$> jsonData
    writeLogString Debug $ show txn
    liftBase $ atomically $ writeTQueue cfgArtifactOutbound $ toMessage $ UserTransaction txn

  post "/api/v1/registry" $ log $ do
    reg <- jsonData
    writeLogString Debug $ show reg
    let Registration {..} = reg
    Config {..} <- ask
    liftBase $ atomically $ modifyTVar cfgRegistry $ \ accum@(lock, entries) ->
      if lock then accum else (lock, nub $ (regNodeId, regPublicKey) : entries)

events
  :: Serialise a
  => TChan a
  -> StreamingBody
events chan send flush = fix $ \ loop -> do
  builder <- fromLazyByteString . encode . serialise <$> (atomically $ readTChan chan)
  case eventToBuilder $ ServerEvent Nothing Nothing [builder] of
    Nothing -> pure ()
    Just chunk -> send chunk >> flush >> loop

forbidden
  :: Monad m
  => String
  -> ActionT Text m ()
forbidden msg = do
  status status403
  json $ object ["error" .= toJSON msg]

log
  :: MonadBase IO m
  => MonadReader Config m
  => ActionT Text m ()
  -> ActionT Text m ()
log action = do
  req <- request
  writeLogString Debug $ show req
  action
