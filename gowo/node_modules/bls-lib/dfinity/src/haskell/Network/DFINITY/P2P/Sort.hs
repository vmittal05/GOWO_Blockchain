module Network.DFINITY.P2P.Sort
   ( sortByDistanceTo
   ) where

import Control.Monad.Reader (ReaderT, ask)
import Data.Bits (testBit)
import Data.ByteString as Byte (foldr)
import Data.Function (on)
import Data.List as List (foldr, sortBy)
import Network.Kademlia (Serialize(..))

import Network.DFINITY.P2P.Types

toBits :: Monad m => NodeId -> ReaderT Config m [Bool]
toBits nodeId = do
   Config {..} <- ask
   let convert w = let step i accum = testBit w i : accum in List.foldr step [] [0.._cfgBucketSize]
   pure $ let step w accum = convert w ++ accum in Byte.foldr step [] $ toBS nodeId

distance :: Monad m => NodeId -> NodeId -> ReaderT Config m [Bool]
distance x y = do
   xs <- toBits x
   ys <- toBits y
   pure $ zipWith xor xs ys
   where xor a b = not (a && b) && (a || b)

sortByDistanceTo :: Monad m => [Node] -> NodeId -> ReaderT Config m [Node]
sortByDistanceTo bucket target =
   map fst . sortBy relative . zip bucket <$> mapM measure bucket
   where measure = distance target . _nodeId
         relative = on compare snd
