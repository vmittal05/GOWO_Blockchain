module Network.DFINITY.Conduit (runConduit) where

import Codec.Serialise               (serialise, deserialiseOrFail)
import Control.Concurrent.STM.TQueue (readTQueue)
import Control.Monad                 ((<=<), forever)
import Control.Monad.Base            (MonadBase(..))
import Control.Monad.Reader          (MonadReader(..))
import Control.Monad.STM             (atomically)
import Control.Monad.Trans.Class     (lift)
import Control.Monad.Trans.Control   (MonadBaseControl)
import Control.Monad.Trans.Resource  (MonadResource)
import Data.ByteString.Lazy          (fromStrict, toStrict)
import Data.Conduit                  (ConduitM, Sink, Source, ($=), ($$), awaitForever, yield)
import Data.Conduit.TMChan           (mergeSources)

import Network.DFINITY.Config
import Network.DFINITY.Log
import Network.DFINITY.Message
import Network.DFINITY.P2P
import Network.DFINITY.Security

runConduit
  :: MonadBase IO m
  => MonadBaseControl IO m
  => MonadReader Config m
  => MonadResource m
  => ConduitM Message Message m ()
  -> m ()
runConduit conduit =
  messageSource $= rateLimiter $= conduit $$ messageSink

messageSource
  :: MonadBase IO m
  => MonadBaseControl IO m
  => MonadReader Config m
  => MonadResource m
  => Source m Message
messageSource =
  -- TODO (enzo): Measure appropriate queue size.
  id <=< lift $ mergeSources [messageSourceP2P, messageSourceUI] 1000

messageSourceP2P
  :: MonadBase IO m
  => MonadReader Config m
  => Source m Message
messageSourceP2P = do
  Config {..} <- ask
  forever $ do
    (,) bytes _ <- liftBase $ p2pReceive cfgInterface
    case deserialiseOrFail $ fromStrict bytes of
      Left err -> do
        writeLogString Debug (show err)
        -- TODO (enzo): Disconnect from sender.
      Right message -> yield message

messageSourceUI
  :: MonadBase IO m
  => MonadReader Config m
  => Source m Message
messageSourceUI = do
  Config {..} <- ask
  forever $ do
    message <- liftBase $ atomically $ readTQueue cfgArtifactOutbound
    yield message

messageSink
  :: MonadBase IO m
  => MonadReader Config m
  => Sink Message m ()
messageSink = do
  Config {..} <- ask
  awaitForever $ liftBase . p2pSend cfgInterface . toStrict . serialise
