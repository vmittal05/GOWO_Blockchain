module Network.DFINITY.P2P
   ( p2pNew
   , p2pAddresses
   , p2pStreams
   , p2pSend
   , p2pReceive
   , p2pBan
   , p2pRequest
   , p2pShutdown
   , p2pSync
   ) where

import Control.Concurrent.STM.TBQueue (isFullTBQueue, readTBQueue, writeTBQueue)
import Control.Concurrent.STM.TVar (modifyTVar, readTVar)
import Control.Exception (SomeException(..), try)
import Control.Monad.STM (atomically)
import Crypto.Hash.SHA256 (hash)
import Data.ByteString.Char8 (ByteString)
import Data.ByteString.Short (toShort)
import Data.LruCache as LRU (insert, lookup)
import Data.Map.Merge.Strict (mapMissing, merge, zipWithMatched)
import Data.Map.Strict as Map (Map, lookup)
import Data.Word (Word64)
import Network.Socket as Socket (Family(..), SocketType(..), connect, socket, socketToHandle)
import System.IO (Handle, IOMode(..), hFlush, hPutChar)
import System.Random (randomRIO)
import System.Timeout (timeout)

import Network.DFINITY.P2P.AddressBook
import Network.DFINITY.P2P.Interface
import Network.DFINITY.P2P.Types
import Network.DFINITY.P2P.Utilities

p2pNew :: Config -> IO Interface
p2pNew = createInterface

p2pAddresses
   :: Interface
   -> [String]
p2pAddresses = _p2pAddresses

p2pStreams
   :: Interface
   -> IO (Map Epoch (Int, Int))
p2pStreams Interface {..} = do
   preds <- atomically $ countOnline <$$> readTVar _p2pPredecessors
   succs <- atomically $ countOnline <$$> readTVar _p2pSuccessors
   pure $ merge missSuccs missPreds match preds succs
   where
   missSuccs = mapMissing $ const ( ,0)
   missPreds = mapMissing $ const (0, )
   match = zipWithMatched $ const ( , )

countOnline
   :: HasStatus a
   => [a]
   -> Int
countOnline = flip foldl 0 $ \ accum x ->
   if getStatus x == Online
   then accum + 1
   else accum

p2pSend
   :: Interface
   -> ByteString
   -> IO ()
p2pSend Interface {..} artifact = do
   let checksum = toShort $ hash artifact
   (,,) epoch successors witnesses <- atomically $ do
      modifyTVar _p2pArtifactCache $ LRU.insert checksum ()
      epoch <- readTVar _p2pEpoch
      successors <- readTVar _p2pSuccessors
      witnesses <- maybe [] fst . LRU.lookup checksum <$> readTVar _p2pWitnessCache
      pure $ (epoch, successors, witnesses)
   let current = maybe [] id $ Map.lookup epoch successors
   flip mapM_ current $ \ case
      Successor {..} | _succStatus == Online && not (_succNodeId `elem` witnesses) ->
         atomically $ do
            full <- isFullTBQueue _succSendQueue
            if full then pure ()
            else writeTBQueue _succSendQueue artifact
      _ -> pure ()

p2pSync :: Interface -> Maybe NodeId -> IO (Either String Handle)
p2pSync Interface {..} = \ case
   Nothing -> do
      network <- atomically $ readTVar _p2pBuckets
      let n = length network
      if n < 1
      then pure $ Left "empty network"
      else do
         i <- randomRIO (0, n-1)
         go $ network !! i
   Just nodeId -> go nodeId
   where
   go nodeId = do
      mval <- timeout 10000000 $ getAddress _p2pAddressBook nodeId
      case mval of
         Nothing -> pure $ Left "no address in book"
         Just nodeAddr -> do
            sockAddr <- convert nodeAddr
            sockId <- socket AF_INET Stream 0
            eval <- try $ connect sockId sockAddr
            case eval :: _ SomeException _ of
               Left err -> pure $ Left $ show err
               Right () -> do
                  handle <- socketToHandle sockId ReadWriteMode
                  hPutChar handle '1'
                  hFlush handle
                  pure $ Right handle

p2pReceive
   :: Interface
   -> IO (ByteString, NodeId)
p2pReceive = atomically . readTBQueue . _p2pReceive

p2pBan :: Interface -> NodeId -> Word64 -> IO ()
p2pBan = error "TODO: p2pBan"

p2pRequest :: Interface -> ByteString -> NodeId -> IO ByteString
p2pRequest = error "TODO: p2pRequest"

p2pShutdown :: Interface -> IO ()
p2pShutdown = destroyInterface
