{-# LANGUAGE ScopedTypeVariables, DeriveAnyClass #-}

module Network.DFINITY.Bootstrap where

import Codec.Serialise               (Serialise)
import Control.Arrow                 (second)
import Control.Concurrent.MVar       (MVar, tryReadMVar)
import Control.Concurrent.STM        (atomically)
import Control.Concurrent.STM.TQueue (TQueue, writeTQueue, readTQueue)
import Control.Monad                 (forM, when, (>=>))
import Data.Aeson                    (FromJSON(..), ToJSON(..))
import Data.ByteString               (ByteString)
import Data.Maybe                    (fromJust)
import GHC.Generics                  (Generic)
import Network                       (HostName, PortNumber)

import qualified Data.HashTable.IO as HT
import qualified Data.Vector as V
import qualified Crypto.BLS as BLS
import qualified Crypto.Secp256k1 as SEC
import qualified System.Logger as L

import Network.DFINITY.Consensus
import Network.DFINITY.P2P
import Network.DFINITY.P2P.TLS
import Network.DFINITY.P2P.Types
import Network.DFINITY.Process

bootstrap
  :: FilePath
  -> TQueue Command
  -> HostName
  -> PortNumber
  -> PortNumber
  -> HostName
  -> PortNumber
  -> PortNumber
  -> FilePath
  -> NodeId
  -> [NodeAddr]
  -> IO Interface
bootstrap certificate controller extIP extTCPPort extUDPPort intIP intTCPPort intUDPPort key nodeId nodes = do
  params <- tlsServerParams key certificate
  p2pNew $ Config
     { _cfgArtifactCacheSize = 10000
     , _cfgBucketSize = 16
     , _cfgController = controller
     , _cfgDebug = const $ pure ()
     , _cfgError = const $ pure ()
     , _cfgExternIP = extIP
     , _cfgExternTCPPort = extTCPPort
     , _cfgExternUDPPort = extUDPPort
     , _cfgInternIP = intIP
     , _cfgInternTCPPort = intTCPPort
     , _cfgInternUDPPort = intUDPPort
     , _cfgNodeId = nodeId
     , _cfgSeedNodes = nodes
     , _cfgServerParams = params
     , _cfgSnapshot = Nothing
     , _cfgWitnessCacheSize = 10000
     }

data NotaryInfo a
  = NotaryInfo 
  { groupIndex :: Int
  , notaryId :: NotaryId
  , memberId :: BLS.MemberId
  , extraInfo :: a
  } deriving (Eq, Show, Generic, Serialise)

type NotaryPublicInfo = NotaryInfo ()

type NotaryFullInfo = NotaryInfo NotarySecret

type GenesisKeys = KeyFrame NotaryFullInfo

type GenesisKeyFrame = KeyFrame NotaryPublicInfo

type HashedKeyFrame = Hashed256 GenesisKeyFrame

data KeyFrame a
  = KeyFrame
  { groupInfo :: V.Vector (BLS.PublicKey, Threshold)
  , minerKeys :: V.Vector (MinerId, V.Vector a)
  } deriving (Eq, Generic)

toPublicKeyFrame :: KeyFrame NotaryFullInfo -> KeyFrame NotaryPublicInfo
toPublicKeyFrame x = 
  KeyFrame 
  { groupInfo = groupInfo x
  , minerKeys = V.map (second $ V.map (\info -> info { extraInfo = () })) $ minerKeys x
  }

deriving instance FromJSON a => FromJSON (KeyFrame a)
deriving instance ToJSON a => ToJSON (KeyFrame a)
deriving instance Serialise a => Serialise (KeyFrame a)

instance ToJSON a => ToJSON (NotaryInfo a) where
  toJSON (NotaryInfo a b c d) = toJSON (a, b, c, d)
  toEncoding (NotaryInfo a b c d) = toEncoding (a, b, c, d)

instance FromJSON a => FromJSON (NotaryInfo a) where
  parseJSON = parseJSON >=> \(a, b, c, d) -> return (NotaryInfo a b c d)

createGenesis
  :: L.Logger
  -> MVar ProcessQueue
  -> MinerIds
  -> Int
  -> Int
  -> IO (NotarizedBlock GenesisKeys)
createGenesis cfgLogger primea mids m s = do
  when (m < 1 || s < 1) $ fail "non-positive group count or group size"
  let t = s `div` 2 + 1
      gids = createGroups () m s mids
  groups <- mapM (generateGroup t) gids
  print gids
  print groups
  let gpks = V.fromList $ map (\(k, _, _) -> k) groups  
      ginfo = V.map (\gpk -> (gpk, fromIntegral t)) gpks
  mnks <- V.forM mids $ \mid -> do
            group <- forM (zip3 [0..] gids groups) $ \(j, ids, (_, nids, ntbl)) -> do
                   case V.elemIndex mid ids of
                     Just i -> do
                       let nid = nids V.! i
                       (mid, nsk) <- fromJust <$> HT.lookup ntbl nid
                       return [NotaryInfo j nid mid nsk]
                     Nothing -> return []
            return (mid, V.fromList $ concat group)
  let gks = KeyFrame ginfo mnks
      beacon = Beacon (BLS.Signature "DFINITY")
      genesisSK = fromJust $ SEC.secKey (hashBytes unitHash)
      genesisPK = SEC.derivePubKey genesisSK
  let blk = hashed256 $ Block 0 beacon genesisPK 0 (Hashed256 unitHash undefined) gks
  (mblk :: MinedBlock GenesisKeys) <- makeSigned' genesisSK genesisPK blk
  genesisGSK <- BLS.deriveSecretKey (hashBytes unitHash)
  genesisGPK <- BLS.derivePublicKey genesisGSK
  stateRoot <- tryReadMVar primea >>= maybe (return unitHash) getRoot
  (sblk :: NotarizedBlock GenesisKeys) <- makeSigned genesisGSK genesisGPK (mblk, stateRoot)
  let nblk = hashed256 sblk -- replaceParent nblk (hashed256 sblk)
  return $ unhashed nblk
  where 
    getRoot ProcessQueue{..} = do
      atomically $ writeTQueue processOutbound ("get_root", "")
      atomically (readTQueue processInbound) >>= \case 
        ("root", hash) -> return $ Hash256 hash
        ("exit", _) -> do
          L.log cfgLogger L.Warn $ L.msg ("failed to start primea, fall back to empty state root" :: ByteString)
          return unitHash
        x -> error $ "error getting state root from primea: " ++ show x

