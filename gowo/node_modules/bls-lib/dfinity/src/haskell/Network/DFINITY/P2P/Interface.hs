module Network.DFINITY.P2P.Interface
   ( createInterface
   , destroyInterface
   ) where

import Control.Concurrent (forkIO, killThread)
import Control.Concurrent.STM.TBQueue (newTBQueueIO)
import Control.Concurrent.STM.TQueue (newTQueueIO)
import Control.Concurrent.STM.TVar (newTVarIO, readTVar)
import Control.Monad.STM (atomically)
import Data.LruCache as LRU (empty)
import Data.Map as Map (elems, empty)
import Network.Socket (Family(..), SocketOption(..), SocketType(..), bind, close, listen, setSocketOption, socket)
import Network.TLS (contextClose)
import System.IO (hClose)

import Network.DFINITY.P2P.AddressBook (createAddressBook, destroyAddressBook, putAddress, shareAddressBook)
import Network.DFINITY.P2P.Dispatcher (runDispatcher)
import Network.DFINITY.P2P.Server (runServer)
import Network.DFINITY.P2P.Types (Config(..), Interface(..), NodeAddr(..), Predecessor(..), Successor(..))
import Network.DFINITY.P2P.Utilities (convert)

-- |
-- Create a network interface.
createInterface :: Config -> IO Interface
createInterface config = do

   -- Create an instance of the distributed address book.
   --
   -- TODO: The distributed address book is not secure and should be replaced
   -- with a Kademlia-like peer discovery protocol as soon as possible.
   addressBook <- createAddressBook config
   shareAddressBook addressBook _cfgSeedNodes
   putAddress addressBook _cfgNodeId extern
   buckets <- newTVarIO []

   -- Create the predecessor and successor context maps.
   epoch <- newTVarIO 0
   predecessors <- newTVarIO Map.empty
   successors <- newTVarIO Map.empty
   whitelist <- newTVarIO []

   -- Create the artifact and witness caches.
   artifactCache <- newTVarIO $ LRU.empty _cfgArtifactCacheSize
   witnessCache <- newTVarIO $ LRU.empty _cfgWitnessCacheSize

   -- Create the send and receive queues.
   send <- newTQueueIO
   receive <- newTBQueueIO 100

   -- Create a socket to be used by the TLS server.
   socketId <- socket AF_INET Stream 0
   setSocketOption socketId ReusePort 1
   socketAddr <- convert intern
   bind socketId socketAddr
   listen socketId 64

   -- Start the dispatcher.
   dispatcher <- forkIO $ runDispatcher addressBook buckets _cfgController epoch
      _cfgNodeId successors whitelist

   -- Start the TLS server.
   server <- forkIO $ runServer _cfgServerParams socketId predecessors receive
      artifactCache witnessCache whitelist

   -- Return the interface.
   return $ Interface addressBook [show extern] artifactCache buckets dispatcher
      epoch predecessors receive send server socketId successors whitelist
      witnessCache

   where
   Config {..} = config
   intern = NodeAddr _cfgInternIP _cfgInternTCPPort
   extern = NodeAddr _cfgExternIP _cfgExternTCPPort

-- |
-- Release all resources associated with a network interface.
destroyInterface :: Interface -> IO ()
destroyInterface Interface {..} = do
   killThread _p2pDispatcher
   killThread _p2pServer
   predecessors <- atomically $ readTVar _p2pPredecessors
   successors <- atomically $ readTVar _p2pSuccessors
   mapM_ destroyPredecessor $ concat $ elems predecessors
   mapM_ destroySuccessor $ concat $ elems successors
   destroyAddressBook _p2pAddressBook
   close _p2pSocket

-- |
-- Release all resources associated with a predecessor.
destroyPredecessor :: Predecessor -> IO ()
destroyPredecessor Predecessor {..} = do
   killThread _predThreadId
   contextClose _predContext
   hClose _predHandle

-- |
-- Release all resources associated with a successor.
destroySuccessor :: Successor -> IO ()
destroySuccessor Successor {..} = do
   killThread _succThreadId
