module Network.DFINITY.Register
   ( Registration(..)
   , runRegistration
   ) where

import Control.Concurrent (threadDelay)
import Control.Concurrent.Async (async, link)
import Control.Concurrent.MVar (readMVar)
import Control.Concurrent.STM.TQueue (TQueue, writeTQueue)
import Control.Exception (try)
import Control.Monad ((<=<))
import Control.Monad.Base (MonadBase, liftBase)
import Control.Monad.Catch (MonadThrow)
import Control.Monad.Reader (MonadReader(..))
import Control.Monad.STM (atomically)
import Control.Monad.Trans.Control (MonadBaseControl)
import Control.Monad.Trans.Resource (ResourceT, resourceForkWith)
import Crypto.BLS (Signature)
import Crypto.Secp256k1 (PubKey)
import Data.Aeson (FromJSON, ToJSON, encode, decode)
import Data.Bool (bool)
import Data.Function (fix)
import Data.Word (Word16)
import GHC.Generics (Generic)
import Network.HTTP.Conduit (Request(..), RequestBody(..), parseRequest)
import Network.HTTP.Simple (HttpException, getResponseStatusCode, getResponseBody, httpNoBody, httpLBS)
import Text.Printf (printf)

import Network.DFINITY.Config (Config(..))
import Network.DFINITY.Log (Level(..), writeLogString)
import Network.DFINITY.Orphan ()
import Network.DFINITY.P2P.Crypto (deriveKautz)
import Network.DFINITY.P2P.Types (Command(..), Epoch, NodeId)

data Registration
   = Registration
   { regNodeId :: NodeId
   , regPublicKey :: PubKey
   } deriving (Generic, Show)

instance FromJSON Registration
instance ToJSON Registration

-- |
-- Run the registration protocol.
runRegistration
   :: MonadBaseControl IO m
   => MonadReader Config m
   => MonadThrow m
   => TQueue Command
   -> NodeId
   -> Bool
   -> String
   -> Word16
   -> ResourceT m ()
runRegistration controller nodeId secure host port = do
   Config {..} <- ask
   resourceForkWith fork $ do
      liftBase $ readMVar cfgReady
      let miner = Registration nodeId cfgPublicKey
      putMiner registry 10000000 miner
      fix $ \ retry -> do
         (beacon, epoch, network) <- getMiners registry 10000000
         control $ Configure network
         if not $ elem nodeId network
         then do
            liftBase $ threadDelay 600000000
            retry
         else do
            let (preds, succs) = deriveKautz nodeId network beacon
            control $ Setup epoch preds succs
            control Rotate
   where
   control = liftBase . atomically . writeTQueue controller
   fork = link <=< async
   registry = getURL secure host port

-- |
-- Get the URL of the registry.
getURL :: Bool -> String -> Word16 -> String
getURL secure host port =
   printf "%s://%s:%d/api/v1/registry" proto host port
   where
   proto = "http" ++ bool "" "s" secure

-- |
-- Put a miner into the registry.
putMiner
   :: MonadBase IO m
   => MonadReader Config m
   => MonadThrow m
   => String
   -> Int
   -> Registration
   -> m ()
putMiner registry retryDelay miner = do
   req <- fmap modify $ parseRequest registry
   fix $ \ retry -> do
      result <- liftBase $ try $ httpNoBody req
      case result :: _ HttpException _ of
         Left err -> do
            writeLogString Error $ show err
            liftBase $ threadDelay retryDelay
            retry
         Right resp ->
            case getResponseStatusCode resp of
               200 -> pure ()
               code -> do
                  writeLogString Error $ "unexpected status code " ++ show code
                  liftBase $ threadDelay retryDelay
                  retry
   where
   modify req = req {
      method = "POST",
      requestBody = RequestBodyLBS $ encode miner
   }

-- |
-- Get a complete list of miners from the registry.
getMiners
   :: MonadBase IO m
   => MonadReader Config m
   => MonadThrow m
   => String
   -> Int
   -> m (Signature, Epoch, [NodeId])
getMiners registry retryDelay = do
   req <- parseRequest registry
   fix $ \ retry -> do
      result <- liftBase $ try $ httpLBS req
      case result :: _ HttpException _ of
         Left err -> do
            writeLogString Error $ show err
            liftBase $ threadDelay retryDelay
            retry
         Right resp ->
            case decode $ getResponseBody resp of
               Nothing -> do
                  writeLogString Debug "miners not yet available"
                  liftBase $ threadDelay retryDelay
                  retry
               Just miners -> pure miners
