module Network.DFINITY.Monitor (runMonitor, writeMetric) where

import Control.DeepSeq                (force)
import Control.Concurrent.Async       (async, link)
import Control.Concurrent.STM.TQueue  (readTQueue, writeTQueue)
import Control.Exception              (try)
import Control.Monad                  ((<=<), forever, void)
import Control.Monad.Base             (MonadBase(..))
import Control.Monad.Reader           (MonadReader(..))
import Control.Monad.STM              (atomically)
import Control.Monad.Trans.Control    (MonadBaseControl)
import Control.Monad.Trans.Resource   (ResourceT, resourceForkWith)
import Data.Word                      (Word16)
import Network.Monitoring.Riemann.TCP (TCPConnection, sendEvents, tcpConnection)

import Network.DFINITY.Config
import Network.DFINITY.Log
import Network.DFINITY.Metric

runMonitor
  :: MonadBaseControl IO m
  => MonadReader Config m
  => String
  -> Word16
  -> ResourceT m ()
runMonitor host port = do
  Config {..} <- ask
  resourceForkWith fork $ do
    result <- liftBase $ try $ tcpConnection host $ fromIntegral port
    case result :: Either IOError TCPConnection of
      Right conn -> liftBase $ forever $ do
        metric <- atomically $ readTQueue cfgMetrics
        let events = encode metric
        sendEvents conn events
      Left err -> do
        writeLogString Warn $ "cannot connect to network monitor: " ++ show err
        liftBase $ forever $ void $ atomically $ readTQueue cfgMetrics
      where fork = link <=< async

writeMetric
  :: MonadBase IO m
  => MonadReader Config m
  => Metric
  -> m ()
writeMetric metric = do
  Config {..} <- ask
  liftBase $ atomically $ writeTQueue cfgMetrics $ force metric
