module Network.DFINITY.Orphan () where

import Codec.Serialise           (Serialise)
import Control.DeepSeq           (NFData(..))
import Control.Monad             ((>=>), mzero)
import Control.Monad.Except      (mapExceptT)
import Control.Monad.Reader      (MonadReader(..), mapReaderT)
import Control.Monad.State.Lazy  (StateT(..), evalStateT)
import Control.Monad.Trans.Class (lift)
import Crypto.BLS                (SecretKey(..), MemberId(..), PublicKey(..), Signature(..))
import Crypto.Hash.SHA256        (hash)
import Crypto.Secp256k1          (Msg, PubKey, SecKey, Sig, derivePubKey, exportPubKey, exportSig, msg, importPubKey, importSig, secKey, signMsg)
import Data.Aeson                (FromJSON(..), ToJSON(..), Value(..), pairs, object, (.:), (.=))
import Data.Binary               (Binary(..))
import Data.ByteString.Base64    (decodeLenient, encode)
import Data.ByteString.Char8     (ByteString, length, maximum)
import Data.Default.Class        (Default(..))
import Data.Maybe                (fromJust)
import Data.Monoid               (mempty, (<>))
import Data.Text.Encoding        (decodeUtf8, encodeUtf8)
import Data.Time.Exts            (Calendar(..), UnixDateTimeNanos(..), parseUnixDateTimeNanos)
import Network                   (PortNumber)
import Prelude hiding            (length, maximum)
import System.Locale             (defaultTimeLocale)
import System.Logger             (ToBytes, bytes, Level)
import Web.Scotty.Internal.Types (ActionT(..), ScottyError)

import Network.DFINITY.Consensus hiding (Signature)

instance ToBytes () where
  bytes () = "()"

instance (ScottyError e, MonadReader r m) => MonadReader r (ActionT e m) where
  ask = lift ask
  local f = mapActionT $ local f

instance FromJSON ByteString where
  parseJSON = \ case
    String text -> pure $ decodeLenient $ encodeUtf8 text
    _ -> mzero

instance ToJSON ByteString where
  toJSON = String . decodeUtf8 . encode

instance (Serialise a, FromJSON a) => FromJSON (Hashed256 a) where
  parseJSON v = hashed256 <$> parseJSON v

instance (Serialise a, FromJSON a) => FromJSON (Signed a 'Secp256k1) where
  parseJSON (Object v) = Signed <$>
                           v .: "content" <*>
                           v .: "signer" <*>
                           (SigSEC <$> v .: "signature")
  parseJSON _ = mzero

instance ToJSON a => ToJSON (Hashed256 a) where
  toJSON Hashed256{..} = toJSON unhashed
  toEncoding Hashed256{..} = toEncoding unhashed

instance ToJSON a => ToJSON (Signed a 'Secp256k1) where
  toJSON Signed{..} = object ["content" .= unhashed content, "signer" .= signer, "signature" .= getSigSEC signature]
  toEncoding Signed{..} = pairs ("content" .= unhashed content <> "signer" .= signer <> "signature" .= getSigSEC signature)

instance (Serialise a, Monoid a) => Monoid (Hashed256 a) where
  mempty = hashed256 mempty
  mappend x y = hashed256 $ mappend (unhashed x) (unhashed y)

instance NFData Level where
  rnf = flip seq ()

instance Default Msg where
  def = fromJust $ msg $ hash mempty

instance FromJSON PortNumber where
   parseJSON = \ case
      Number n -> pure $ truncate n
      _ -> mzero

instance ToJSON PortNumber where
   toJSON = Number . fromIntegral

instance Binary PubKey where
  put = put . exportPubKey True
  get = maybe def id . importPubKey <$> get

instance Default PubKey where
  def = derivePubKey def

instance FromJSON PubKey where
  parseJSON = parseJSON >=> maybe mzero pure . importPubKey

instance NFData PubKey where
  rnf = flip seq ()

instance ToJSON PubKey where
  toJSON = toJSON . exportPubKey True

instance FromJSON PublicKey where
  parseJSON = parseJSON >=> \ bytes ->
    if length bytes /= 64 || maximum bytes == '\NUL'
    then mzero else pure $ PublicKey bytes

deriving instance NFData PublicKey

instance FromJSON SecretKey where
  parseJSON = parseJSON >=> return . SecretKey

instance FromJSON MemberId where
  parseJSON = parseJSON >=> return . MemberId

instance ToJSON MemberId where
  toJSON = toJSON . getMemberId

instance ToJSON SecretKey where
  toJSON = toJSON . getSecretKey

instance ToJSON PublicKey where
  toJSON = toJSON . getPublicKey

instance Default SecKey where
  def = fromJust $ secKey $ hash mempty

instance Binary Sig where
  put = put . exportSig
  get = maybe def id . importSig <$> get

instance Default Sig where
  def = signMsg def def

instance FromJSON Sig where
  parseJSON = parseJSON >=> maybe mzero pure . importSig

instance NFData Sig where
  rnf = flip seq ()

instance ToJSON Sig where
  toJSON = toJSON . exportSig

instance FromJSON Signature where
  parseJSON = parseJSON >=> \ bytes ->
    if length bytes /= 32 || maximum bytes == '\NUL'
    then mzero else pure $ Signature bytes

deriving instance NFData Signature

instance ToJSON Signature where
  toJSON = toJSON . getSignature

instance FromJSON (UnixDateTimeNanos 'Gregorian) where
  parseJSON = \ case
    String text -> either (const mzero) pure $ parseUnixDateTimeNanos defaultTimeLocale "%I:%M:%S%f %p %a %b %d %Y" text
    _ -> mzero

instance ToJSON (UnixDateTimeNanos 'Gregorian) where
  toJSON = toJSON . show

mapActionT :: (Monad η, Monad µ, ScottyError e) => (forall a . η a -> µ a) -> ActionT e η b -> ActionT e µ b
mapActionT f action = ActionT $ flip mapExceptT except $ \ reader -> flip mapReaderT reader $ \ state -> StateT $ \ x -> (,x) <$> f (evalStateT state x) where except = runAM action
