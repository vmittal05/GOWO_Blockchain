{-# LANGUAGE LambdaCase #-}
module Network.DFINITY.Process (ProcessQueue(..), runProcess) where

import Control.Concurrent            (forkIO, killThread)
import Control.Concurrent.MVar       (MVar, newMVar, tryTakeMVar)
import Control.Concurrent.STM.TQueue (TQueue, newTQueueIO, readTQueue, writeTQueue)
import Control.Monad                 (forever, void)
import Control.Monad.IO.Class        (liftIO)
import Control.Monad.STM             (atomically)
import Control.Monad.Trans.Resource  (MonadResource, allocate)
import Data.ByteString.Char8         (ByteString, pack)
import Data.List.NonEmpty            (NonEmpty(..))
import Data.Word                     (Word16)
import System.IO                     (hPutStrLn, stderr)
import System.Process                (createProcess, interruptProcessGroupOf, shell, waitForProcess)
import System.ZMQ4                   (Pair(..), bind, close, context, receiveMulti, sendMulti, socket, term)
import Text.Printf                   (printf)

data ProcessQueue 
  = ProcessQueue
  { processInbound :: TQueue (ByteString, ByteString)
  , processOutbound :: TQueue (ByteString, ByteString)
  }

runProcess
  :: MonadResource m
  => String
  -> String
  -> String
  -> String
  -> Word16
  -> m (MVar ProcessQueue)
runProcess script db proto ip port = do
  inbound <- liftIO newTQueueIO
  outbound <- liftIO newTQueueIO
  queue <- liftIO $ newMVar (ProcessQueue inbound outbound)
  ctx <- snd <$> allocate context term
  let pair = socket ctx Pair
  interface <- snd <$> allocate pair close
  liftIO $ bind interface address
  void $ flip allocate killThread $ forkIO $ forever $ do
    message <- receiveMulti interface
    case message of
      [subject, body] -> atomically $ writeTQueue inbound (subject, body)
      _ -> hPutStrLn stderr $ "invalid message: " ++ show message
  void $ flip allocate killThread $ forkIO $ forever $ do
    (subject, body) <- atomically $ readTQueue outbound
    sendMulti interface $ subject :| [body]
  (_, handle) <- allocate ((\(_, _, _, handle) -> handle) <$> process) interruptProcessGroupOf
  void $ flip allocate killThread $ forkIO $ do
    exitCode <- waitForProcess handle
    hPutStrLn stderr $ "Process " ++ script ++ " finishes with " ++ show exitCode
    atomically $ writeTQueue inbound ("exit", pack (show exitCode))
    void $ tryTakeMVar queue
  pure queue
  where
    script_with_args = printf "%s --db=%s --proto=%s --ip=%s --port=%d" script db proto ip port
    address = printf "%s://%s:%d" proto ip port
    process = createProcess $ shell script_with_args
