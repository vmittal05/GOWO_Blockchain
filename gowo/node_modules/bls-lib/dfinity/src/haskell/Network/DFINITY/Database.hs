{-# LANGUAGE ScopedTypeVariables #-}

module Network.DFINITY.Database (Hashed256Store(..), openDB, putDB, getDB) where

import Codec.Serialise                (Serialise, deserialise, serialise)
import Control.Concurrent.MVar        (MVar, newMVar, putMVar, takeMVar)
import Control.Monad.Base             (liftBase)
import Control.Monad.Reader           (MonadReader(..))
import Control.Monad.Trans.Resource   (MonadResource, allocate, release)
import Data.ByteString                (ByteString)
--import Data.ByteString.Base16         (encode)
--import Data.ByteString.Builder        (toLazyByteString, word64BE)
import Data.ByteString.Lazy.Char8     (fromStrict, toStrict)
import Data.Default.Class             (def)
import Data.Monoid                    ((<>))
--import Data.Word                      (Word64)
import Database.LevelDB.MonadResource (DB, Options(..), get, open, put)
import System.FilePath                ((</>))
import System.Logger                  (bytes)

import qualified Data.ByteString.Lazy.Char8 as L

import Network.DFINITY.Config
import Network.DFINITY.Consensus
import Network.DFINITY.Transaction

openDB
  :: MonadResource m
  => FilePath
  -> FilePath
  -> m (MVar DB)
openDB dir file = do
  db <- open path def { createIfMissing = True }
  liftBase $ newMVar db
  where path = dir </> file

withDB
  :: MonadResource m
  => MonadReader Config m
  => (DB -> m a)
  -> m a
withDB query = do
  Config {..} <- ask
  (,) key db <- allocate (takeMVar cfgDatabase) (putMVar cfgDatabase)
  result <- query db
  release key
  pure result

getDB
  :: MonadResource m
  => MonadReader Config m
  => ByteString
  -> m (Maybe ByteString)
getDB key = withDB $ \ db -> get db def key

putDB
  :: MonadResource m
  => MonadReader Config m
  => ByteString
  -> ByteString
  -> m ()
putDB key val = withDB $ \ db -> put db def key val

{-
getBlock
  :: MonadResource m
  => MonadReader Config m
  => Word64
  -> m (Maybe (Artifact Block))
getBlock height = do
  mval <- getDB $ getBlockId height
  case mval of
    Nothing -> pure Nothing
    Just bytes ->
      case deserialiseOrFail $ fromStrict bytes of
        Left err -> do
          writeLogString Error (show err)
          pure Nothing
        Right block -> pure $! Just block

putBlock
  :: MonadResource m
  => MonadReader Config m
  => Artifact Block 
  -> m ()
putBlock block@Block {..} =
  putDB key $ toStrict $ serialise block
  where key = getBlockId blockHeight

getBlockId :: Word64 -> ByteString
getBlockId = mappend "block." . encode . toStrict . toLazyByteString . word64BE
-}

getDB' :: (MonadReader Config m, MonadResource m) => Hash256 -> m (Maybe L.ByteString)
getDB' key = fmap fromStrict <$> getDB (hashBytes key)

putDB' :: (MonadReader Config m, MonadResource m) => Hash256 -> L.ByteString -> m ()
putDB' key value = putDB (hashBytes key) (toStrict value)

class Hashed256Store m a where
  storeHashed256 :: Serialise a => Hashed256 a -> m ()
  lookupHashed256 :: Hash256 -> m (Maybe (Hashed256 a))
  removeHashed256 :: Hash256 -> m (Maybe (Hashed256 a))

instance (Serialise a, Serialise (Signed a s), MonadResource m, MonadReader Config m, 
          Hashed256Store m a, SignatureScheme s) => 
        Hashed256Store m (Signed a s) where
  storeHashed256 signed | hashed signed == unitHash = return ()
                        | otherwise = lookupHashed256 (hashed signed) >>= \case
    Just (_ :: Hashed256 (Signed a s)) -> return ()
    Nothing -> do
      let z = serialise (unhashed signed)
      putDB' (hashed signed) z
      storeHashed256 (content (unhashed signed))
  lookupHashed256 x | x == unitHash = return $ Just $ Hashed256 x undefined
                    | otherwise = do
    getDB' x >>= \case
      Nothing -> return Nothing
      Just y -> do
        let signed = deserialise y
            p = content signed
        lookupHashed256 (hashed p) >>= \case
          Nothing -> return (Just $ Hashed256 x signed)
          Just q -> return (Just $ Hashed256 x $ signed { content = q })
  removeHashed256 = undefined -- TODO

instance (Serialise a, MonadReader Config m, MonadResource m) => 
         Hashed256Store m (MinedBlock a, StateRoot) where
  storeHashed256 root = lookupHashed256 (hashed root) >>= \case
    Just (_ :: Hashed256 (MinedBlock (), StateRoot)) -> return ()
    Nothing -> do
      let blk = hashed256 (fst $ unhashed root)
      let z = serialise (hashed blk, snd $ unhashed root)
      putDB' (hashed root) z
      storeHashed256 blk
  lookupHashed256 x = do
    getDB' x >>= \case
      Nothing -> return Nothing
      Just y -> do
        let root :: (Hash256, StateRoot) = deserialise y
        lookupHashed256 (fst root) >>= \case
          Nothing -> error "block associated with the stateroot not found"
          Just blk ->  return (Just $ Hashed256 x (unhashed blk, snd root))
  removeHashed256 = undefined -- TODO
 
instance (Serialise a, MonadReader Config m, MonadResource m) => Hashed256Store m (Block a) where
  storeHashed256 blk = lookupHashed256 (hashed blk) >>= \case
    Just (_ :: Hashed256 (Block ())) -> return ()
    Nothing -> do
      let z = serialise (unhashed blk)
      putDB' (hashed blk) z
      storeHashed256 (parent (unhashed blk))
  lookupHashed256 x = do
    getDB' x >>= \case
      Nothing -> return Nothing
      Just y -> do
        let blk = deserialise y
        -- We do not read the parent of a Block type
        return $ Just $ Hashed256 x blk
  removeHashed256 = undefined -- TODO
 
instance (HasLogger Config, MonadReader Config m, MonadResource m) => Hashed256Store m Transaction where
  storeHashed256 txn = lookupHashed256 (hashed txn) >>= \case
    Just (_ :: Hashed256 Transaction) -> return ()
    Nothing -> do
      let z = serialise (unhashed txn)
      putDB' (hashed txn) z
  lookupHashed256 x = do
    debug $ "lookup user transaction of hash " <> bytes x
    getDB' x >>= \case
      Nothing -> return Nothing
      Just y -> do
        let txn = deserialise y
        return $ Just $ Hashed256 x txn
  removeHashed256 = undefined -- TODO
 

