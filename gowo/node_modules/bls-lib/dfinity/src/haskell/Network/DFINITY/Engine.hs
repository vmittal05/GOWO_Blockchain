{-# LANGUAGE ViewPatterns, ScopedTypeVariables, OverloadedStrings #-}

module Network.DFINITY.Engine (engine) where


import Codec.Serialise               (Serialise, serialise, deserialiseOrFail)
import Control.Arrow                 (first)
import Control.Concurrent            (forkIO, threadDelay)
import Control.Concurrent.MVar       (newMVar, readMVar, tryReadMVar, modifyMVar_, putMVar, isEmptyMVar)
import Control.Concurrent.STM.TQueue (unGetTQueue, readTQueue, writeTQueue)
import Control.Concurrent.STM.TChan  (writeTChan, tryReadTChan)
import Control.Concurrent.STM        (atomically)
import Control.Exception             (Exception)
import Control.Monad                 (forM, forM_, filterM, when, (>=>))
import Control.Monad.Base            (MonadBase(..))
import Control.Monad.Reader          (ReaderT(..), MonadReader(..))
import Control.Monad.State.Strict    (StateT(..), modify', evalStateT, MonadState(..))
import Control.Monad.Trans           (lift, MonadIO, liftIO)
import Control.Monad.Trans.Resource  (MonadThrow(..), MonadResource)
import Data.ByteString.Char8         (pack)
import Data.ByteString.Lazy          (fromStrict, toStrict)
import Data.Conduit                  (ConduitM, await, yield)
import Data.Int                      (Int64)
import Data.List                     (sortBy, groupBy)
import Data.Maybe                    (fromJust)
import Data.Monoid                   (mempty, (<>))
import Data.Time.Exts                (getCurrentUnixDateTime, UnixDateTime(..))
import System.Logger                 (bytes)

import qualified Data.HashTable.IO    as HT
import qualified Data.IntMap.Strict   as IntMap
import qualified Data.Vector          as V
import qualified System.Logger        as L

import Network.DFINITY.Artifact
import Network.DFINITY.Bootstrap
import Network.DFINITY.Config
import Network.DFINITY.Consensus
import Network.DFINITY.Consensus.Membership
import Network.DFINITY.Consensus.Proc (AutoProc, runAutoProc, stateful)
import Network.DFINITY.Database
import Network.DFINITY.Log
import Network.DFINITY.Message
import Network.DFINITY.Process
import Network.DFINITY.Transaction

engine
  :: MonadBase IO m
  => MonadReader Config m
  => MonadIO m
  => MonadResource m
  => ConduitM Message Message m ()
engine = do
  Config {..} <- ask
  await >>= \case
    Nothing -> engine 
    Just msg -> do
      case deserialiseOrFail $ fromStrict $ msgBytes msg of
        Right (SomeArtifact (0x00, bytes)) ->
          case deserialiseOrFail $ fromStrict bytes of
            Right (ArtifactChirp i) -> do
              writeLogString Debug ("chirp " ++ show i ++ "!")
              yield msg
            Left err -> writeLogString Debug (show err)
        Right (view NewGenesis -> Just y) ->
          liftBase (verifySigned y) >>= flip when (do
            yield msg
            liftBase (isEmptyMVar cfgKeyFrame) >>= flip when (do
              liftBase $ putMVar cfgKeyFrame Nothing
              runConsensus y))
        Right _ -> do
          yield msg
          writeLogString Debug "ignore messages before consensus is started"
        Left err -> writeLogString Debug (show err)
      engine

view
  :: Artifacts a
  => Serialise (Artifact a)
  => (a -> ChainEvent) -> SomeArtifact -> Maybe a
view f (SomeArtifact (n, s))
  | n == messageId (f undefined) =
    either (\_ -> Nothing) (Just . fromArtifact) $ deserialiseOrFail (fromStrict s)
  | otherwise = Nothing

-- TODO: cache signature verification result so that consensus can re-use it.
verifySigned'
  :: SignatureScheme s
  => MonadReader Config m
  => Serialise a
  => MonadIO m
  => MonadBase IO m
  => Signed a s -> m (Maybe (Signed a s))
verifySigned' x = liftBase (verifySigned x) >>= \case
  False -> writeLogString Debug "artifact of invalid signature" >> return Nothing
  True -> return (Just x)

toChainEvent
  :: MonadReader Config m
  => MonadBase IO m
  => MonadResource m
  => Message -> ChainM m (Maybe (Message, ChainEvent))
toChainEvent msg =
  case deserialiseOrFail $ fromStrict $ msgBytes msg of
    Right (view NewSignedBeacon   -> Just x) -> fmap ((msg,) . NewSignedBeacon)   <$> verifySigned' x
    Right (view NewMinedBlock     -> Just x) -> fmap ((msg,) . NewMinedBlock)     <$> verifySigned' x
    Right (view NewSignedBlock    -> Just x) -> fmap ((msg,) . NewSignedBlock)    <$> verifySigned' x
    Right (view NewNotarizedBlock -> Just x) -> fmap ((msg,) . NewNotarizedBlock) <$> verifySigned' x
    Right (view UserTransaction   -> Just x) -> fmap ((msg,) . UserTransaction)   <$> verifySigned' x
    Right (view Timeout -> Just x) -> return $ Just (msg, Timeout x)
    _ -> writeLogString Debug "unknown artifact" >> return Nothing

type BlockCache a = IntMap.IntMap [HashedBlock a]

lookupBlockCache' :: Height -> HashedBlock a -> BlockCache a -> Maybe (HashedBlock a)
lookupBlockCache' h blk cache = 
  case IntMap.lookup (fromIntegral h) cache of
    Nothing -> Nothing
    Just blks -> case filter (== blk) blks of
      [] -> Nothing
      x:_ -> Just x

lookupBlockCache :: HashedBlock a -> BlockCache a -> Maybe (HashedBlock a)
lookupBlockCache blk = lookupBlockCache' (heightOf blk) blk

insertBlockCache :: HashedBlock a -> BlockCache a -> BlockCache a
insertBlockCache blk cache = 
  case IntMap.lookup h cache of
    Just blks -> IntMap.insert h (blk:filter (/=blk) blks) cache
    Nothing   -> IntMap.insert h [blk] cache
  where
    h = fromIntegral $ heightOf blk

-- | Remove all blocks equal or less than the given height from block cache
compactBlockCache :: Height -> BlockCache a -> BlockCache a
compactBlockCache h = snd . IntMap.split (fromIntegral h)

sizeOfBlockCache :: BlockCache a -> Int
sizeOfBlockCache = IntMap.size

type TransactionCache = HT.CuckooHashTable Hash256 (SignedTransaction, Height)
type StateRootCache = HT.CuckooHashTable StateRoot Height

data ChainState m
  = ChainState
  { chains :: !(Chains Transactions)
  , epochTable :: !EpochTable
  , notaryGroups :: !NotaryGroups
  , epoch :: !Epoch
  , roundInfo :: !(Maybe RoundInfo)
  , blockCache :: !(BlockCache Transactions)
  , eventCache :: !(IntMap.IntMap [ChainEvent])
  , txnCache   :: !TransactionCache
  , stateRootCache :: !StateRootCache
  , eventQueue :: [ChainEvent]
  , makerState :: !(AutoProc (ReaderT ChainEnv m) ChainEvent ())
  , finalizerState :: !(AutoProc (ReaderT ChainEnv m) ChainEvent ())
  }

type ChainEnv = Config

instance HasNotaryGroups (ChainState m) where
  getNotaryGroups = notaryGroups
  setNotaryGroups groups s = s { notaryGroups = groups }

instance HasEpochTable (ChainState m) where
  getEpochTable = epochTable

instance HasEpoch (ChainState m) where
  getEpoch = epoch
  setEpoch n s = s { epoch = n }

instance (MonadReader Config m, MonadResource m, MonadIO m) => 
         ChainStore (ChainM m) Transactions where
  readChains = do
    ChainState{..} <- get
    debug ("readChains " <> bytes chains)
    return chains
  writeChains x@Chains{..} = do
    debug ("writeChains called " <> bytes x)
    ChainState{..} <- get
    let h = heightOf chainRoot
        nblk:_ = chainTips
        blockCache' = insertBlockCache chainRoot $ compactBlockCache h $ 
                      insertBlockCache nblk $ blockCache
    modify' $ \s -> s { chains = x, blockCache = blockCache' }
    debug ("blockCache size = " <> (bytes $ sizeOfBlockCache blockCache))
    -- remove old transactions to keep cache size down
    liftIO $ HT.toList txnCache >>= 
             mapM_ (\(hash, (_, h')) -> when (h' + 2 < h) (HT.delete txnCache hash))
    -- remove old state roots to keep cache size down
    liftIO $ HT.toList stateRootCache >>= 
             mapM_ (\(hash, h') -> when (h' + 2 < h) (HT.delete stateRootCache hash))
  filterTransactions pblk txns = do
    ChainState{..} <- get
    let hblks = ancestry (chainRoot chains) pblk
        processed = concatMap (map ((,()) . hashed) . fromTransactions . payloadOf) hblks
    (htable :: HT.CuckooHashTable Hash256 ()) <- liftIO $ HT.fromList processed
    fmap toTransactions $ flip filterM (fromTransactions txns) $ \txn -> do
      let h = hashed txn
      liftIO (HT.lookup htable h) >>= \case
        Just _ -> return False
        Nothing -> lookupHashed256 h >>= \case
          Just (_ :: Hashed256 SignedTransaction) -> return False
          Nothing -> return True

newtype ChainM m a 
  = ChainM { runChainM :: StateT (ChainState (ChainM m)) (ConduitM Message Message m) a } 
  deriving (Functor, Applicative, Monad,
            MonadState (ChainState (ChainM m)))

deriving instance MonadIO m => MonadIO (ChainM m)
deriving instance MonadReader r m => MonadReader r (ChainM m)
deriving instance MonadBase n m => MonadBase n (ChainM m)
deriving instance MonadResource m => MonadResource (ChainM m)
deriving instance MonadThrow m => MonadThrow (ChainM m)

runConsensus
  :: MonadBase IO m
  => MonadIO m
  => MonadReader Config m
  => MonadResource m
  => SignedBlock GenesisKeys -> ConduitM Message Message m ()
runConsensus nblk = do
  Config {..} <- ask
  blockTime <- newRef 1000000 -- start with 1 second block time
  chainLength <- newRef 4 
  let (sblk, stateRoot) = unhashed $ content nblk
      Block{..} = unhashed $ content sblk 
      blk = Block height beacon miner rank (Hashed256 unitHash undefined) mempty
      sblk' = Signed (Hashed256 (hashed $ content sblk) blk) (signer sblk) (signature sblk)
      nblk' = Signed (Hashed256 (hashed $ content nblk) (sblk', stateRoot)) (signer nblk) (signature nblk)
      hblk = replaceParent hblk (hashed256 nblk')
      keyframe@KeyFrame{..} = payload
      (minerIds, groups) = V.unzip minerKeys
      i = fromJust $ V.elemIndex cfgPublicKey minerIds
      group = groups V.! i
      htFromList = HT.fromList :: [(NotaryId, a)] -> IO (NotaryTable a)
  liftBase $ modifyMVar_ cfgKeyFrame (\_ -> pure $ Just $ toPublicKeyFrame keyframe)
  writeLogString Debug $ "minerIds = " ++ show minerIds
  writeLogString Debug $ "groups = " ++ show groups
  roles <- liftBase $ htFromList $ V.toList $ V.map (\(NotaryInfo j nid _ ns) -> (fst (groupInfo V.! j), NotaryRole nid ns)) group
  let chainConfig = ChainConfig 1000000 blockTime chainLength cfgLogger
      chains = Chains hblk [hblk]
  minerTable <- liftBase $ HT.fromList $ zip (V.toList minerIds) (repeat ())
  epochTable <- liftBase $ HT.fromList [(0, minerTable)]
  let groupMembers =  map (\x -> (fst $ head x, map snd x)) $ 
                      groupBy (\x y -> fst x == fst y) $ 
                      sortBy (\x y -> compare (fst x) (fst y)) $ concat $
                      map (map (\(NotaryInfo j nid mid _) -> (j, (nid, mid))) . V.toList) $ 
                      V.toList groups
  writeLogString Debug $ "groupMembers = " ++ show groupMembers
  memberLookups <- liftBase $ sequence $ V.fromList $ map (htFromList . snd) $ groupMembers
  txnCache <- liftBase $ HT.new
  stateRootCache <- liftBase $ HT.fromList [(stateRoot, height)]
  let notaryGroups = V.zipWith (\(gid, threshold) mlk -> NotaryGroup gid (NotaryGroupInfo threshold (HT.lookup mlk))) groupInfo memberLookups
      roundInfo = Nothing
      me = Miner cfgPublicKey cfgSecretKey (HT.lookup roles)
      engineState = ChainState chains epochTable notaryGroups 0 roundInfo 
                               (IntMap.fromList [(0, [hblk])]) IntMap.empty 
                               txnCache stateRootCache []
                               (blockmaker me) (finalizer chainConfig)
  _ <- flip evalStateT engineState $ runChainM $ manyEpochs chainConfig me beacon (height + 1)
  return ()

nextEvent :: (MonadReader Config m, MonadBase IO m, MonadResource m) => ChainM m (Message, ChainEvent)
nextEvent = ChainM (lift await) >>= maybe nextEvent (toChainEvent >=> maybe nextEvent return)

data NoKnownStateRootException = NoKnownStateRootException deriving (Eq, Show)
instance Exception NoKnownStateRootException

realizeStateRoot 
  :: MonadIO m
  => MonadReader Config m
  => MonadThrow m
  => Broadcast (ChainM m) ChainEvent
  => StateMachine (ChainM m) Transactions
  => StateRootCache
  -> [HashedBlock Transactions]
  -> ChainM m StateRoot
realizeStateRoot _ [] = throwM NoKnownStateRootException 
realizeStateRoot cache (blk:blks) = do
  debug ("block " <> bytes (unhashed blk))
  let root = snd $ unhashed $ content $ unhashed $ blk
  liftIO (HT.lookup cache root) >>= \case
    Just h -> do
      debug ("root known " <> bytes root)
      h `seq` return root
    Nothing -> do
      debug ("state root not previously known " <> bytes root <> ", need to re-compute block")
      _ <- realizeStateRoot cache blks
      newRoot <- compute (unhashed $ content $ fst $ unhashed $ content $ unhashed $ blk)
      when (newRoot /= root) $ warn ("Mismatched root from computing block " <> bytes (unhashed blk))
      liftIO $ HT.insert cache newRoot (heightOf blk)
      return newRoot

instance (MonadReader Config m, MonadResource m) => Broadcast (ChainM m) ChainEvent where
  broadcast x = do
    debug ("broadcast " <> bytes x)
    report x
    ChainM $ lift $ yield $ toMessage x
  report x = do
    debug ("report " <> bytes x)
    modify' $ \s -> s { eventQueue = x : eventQueue s }
  pump = do
    x <- pump'
    ChainState{..} <- get
    config <- ask
    (m', y) <- flip runReaderT config $ runAutoProc makerState x
    (f', z) <- flip runReaderT config $ runAutoProc finalizerState x
    y `seq` z `seq` modify' $ \s -> s { makerState = m', finalizerState = f' }
    case z of
      Nothing -> return ()
      Just () -> do
        Config{..} <- ask
        Chains{..} <- readChains
        ts <- maybe (0::Int64) (either (const 0) id . deserialiseOrFail . fromStrict) <$>
              getDB ("timestamp." <> hashBytes (hashed chainRoot))
        liftBase $ atomically $ writeTChan cfgArtifactInbound (ts, toArtifact $ unhashed chainRoot)
        let h = heightOf chainRoot
        putDB ("block." <> pack (show h)) $ hashBytes $ hashed chainRoot
        putDB "height" $ toStrict (serialise h)
    debug ("after pump")
    return x
    where
      pump' = do
        Config{..} <- ask
        ChainState{..} <- get
        debug ("before pump")
        let popEvent = case eventQueue of
                         x:xs -> do
                            modify' $ \s -> s { eventQueue = xs }
                            return $ (Nothing, x)
                         [] -> nextEvent >>= return . first Just
        (msg, x) <- popEvent 
        debug ("popEvent returns " <> bytes x)
        let yield' = maybe (return ()) (ChainM . lift . yield) msg
            storeBlock blk = do
              let hblk = hashed256 blk
              storeHashed256 hblk
              UnixDateTime start <- liftBase $ getCurrentUnixDateTime
              putDB ("timestamp." <> hashBytes (hashed hblk)) (toStrict $ serialise start)
        case x of
          NewRoundStart (rinfo, _) -> do
            let h = fromIntegral $ roundHeight rinfo
            case IntMap.lookup h eventCache of
              Just events -> mapM_ report events
              Nothing -> return ()
            let eventCache' = IntMap.delete h eventCache
            debug $ "eventCache size = " <> (bytes $ IntMap.size eventCache)
            modify' $ \s -> s { eventCache = eventCache', roundInfo = Just rinfo }
            _ <- liftBase $ atomically $ tryReadTChan cfgArtifactInbound
            return x
          Timeout _ -> return x
          UserTransaction tx -> do
            let h = maybe 0 roundHeight roundInfo
                hash = hash256 tx
            debug $ "cache transaction of hash " <> bytes hash <> " of height " <> bytes h
            liftBase $ HT.insert txnCache hash (tx, h)
            yield'
            return x
          _ -> do
            let h = maybe 0 roundHeight roundInfo
                h' = getHeight h x
            case compare h' h of
              GT -> do
                debug ("cache future message " <> (bytes $ show (h, h')))
                let events = filter (/=x) $ maybe [] id $ IntMap.lookup (fromIntegral h') eventCache
                    eventCache' = length events `seq` IntMap.insert (fromIntegral h') (x:events) eventCache
                modify' $ \s -> s { eventCache = eventCache' }
                yield'
                pump'
              EQ -> do
                debug ("before reform event")
                let x' = case x of
                           NewMinedBlock x -> NewMinedBlock <$> reformMinedBlock blockCache x
                           NewSignedBlock x -> NewSignedBlock <$> reformSigned blockCache x
                           NewNotarizedBlock x -> NewNotarizedBlock <$> reformSigned blockCache x
                           _ -> Just x 
                debug ("event of current round " <> maybe "" bytes x')
                yield'
                maybe (return ()) storeBlock $ (x' >>= onNotarizedBlock)
                maybe pump' return x'
              LT -> do
                debug ("got old message " <> bytes x)
                let Chains{..} = chains
                    rootHeight = heightOf chainRoot
                when (h' >= rootHeight) yield' -- do not propagate messages too old
                case x of 
                  NewNotarizedBlock blk -> do
                    -- need to make sure block parent exists locally
                    debug ("notarized block received")
                    if h' < rootHeight
                    then do
                      -- TODO: handling chain split
                      warn ("notarized block received is older than finalized root, ignore?")
                      pump'
                    else do
                      case reformSigned blockCache blk of
                        Just blk' -> do
                          debug "old notarized block received, store"
                          storeBlock blk'
                          return (NewNotarizedBlock blk')
                        Nothing -> do
                          -- TODO: some notarized block missing, need to wait or request
                          warn ("orphaned block observed " <> bytes blk)
                          pump'
                  _ -> pump'
    
reformHashedBlock :: IntMap.IntMap [HashedBlock a] -> HashedBlock a -> Maybe (HashedBlock a)
reformHashedBlock blockCache blk = reformHashedBlock' blockCache (heightOf blk) blk

reformHashedBlock' :: IntMap.IntMap [HashedBlock a] -> Height -> HashedBlock a -> Maybe (HashedBlock a)
reformHashedBlock' blockCache h blk = 
  maybe (fmap (flip replaceParent blk) (lookupBlock (h - 1) (parentOf blk))) Just $ lookupBlock h blk
  where
    lookupBlock h blk = 
      case IntMap.lookup (fromIntegral h) blockCache of
        Nothing -> Nothing
        Just cache -> case filter (== blk) cache of
                        [] -> Nothing
                        x:_ -> Just x

reformMinedBlock :: IntMap.IntMap [HashedBlock a] -> MinedBlock a -> Maybe (MinedBlock a)
reformMinedBlock blockCache blk = 
  fmap (flip replaceMinedParent blk) $ 
  reformHashedBlock' blockCache (heightOfMined blk - 1) 
    (parent $ unhashed $ content $ blk)

reformSigned :: IntMap.IntMap [HashedBlock a] -> Signed (MinedBlock a, b) s -> 
                Maybe (Signed (MinedBlock a, b) s)
reformSigned blockCache blk = 
  fmap (flip replaceSignedParent blk) $
  reformHashedBlock' blockCache (heightOfSigned blk - 1) 
    (parent $ unhashed $ content $ fst $ unhashed $ content $ blk)

instance (MonadReader Config m, MonadIO m, MonadResource m) =>
         StateMachine (ChainM m) Transactions where
  compute Block{..} = do
    Config{..} <- ask
    ChainState{..} <- get
    let blks = ancestry (chainRoot chains) parent
    debug ("acenstry start")
    mapM_ (\b -> debug (bytes $ unhashed b)) blks
    debug ("acenstry end")
    s <- realizeStateRoot stateRootCache blks
    let txns = fromTransactions payload
    debug ("to compute transactions: " <> bytes (length txns) <> " on state root " <> bytes s)
    let hashes = map hashed txns
    stxns <- forM hashes $ \h -> liftIO (HT.lookup txnCache h) >>= \case
      Nothing -> do
        warn $ "transaction not found in local cache: " <> bytes h
        return []
      Just (x, _) -> return [x :: SignedTransaction] 
    let txns' = map (unhashed . content) $ concat stxns
    debug ("retrieved transactions: " <> bytes (length txns'))
    s' <- liftIO (tryReadMVar cfgPrimea) >>= maybe (return s) (compute' s txns')
    liftIO $ HT.insert stateRootCache s' height
    return s'
    where
      run = liftIO . atomically
      compute' root txns ProcessQueue{..} = do
        run (writeTQueue processOutbound ("txn_start", toStrict $ serialise root))
        run (readTQueue processInbound) >>= \case
          ("txn_start", start_msg) -> case deserialiseOrFail $ fromStrict $ start_msg of
            Right (txn_id :: Int) -> do
              forM_ txns $ run . writeTQueue processOutbound . ("txn_run",) . toStrict . serialise
              run (writeTQueue processOutbound ("txn_end", ""))
              run (readTQueue processInbound) >>= \case
                ("txn_end", end_msg) -> case deserialiseOrFail $ fromStrict $ end_msg of
                  Right (txn_id', newStateRoot) -> if txn_id == txn_id' 
                    then return newStateRoot 
                    else do
                      warn $ "transaction id mismatch " <> bytes (show (txn_id', txn_id))
                      return root
                  x -> do
                    warn $ "txn_end decode failure: " <> bytes (show x)
                    return root
                x -> do
                  warn $ "expecting txn_end, but received " <> bytes (show x)
                  return root
            x -> do
              warn $ "txn_start decode failure: " <> bytes (show x)
              return root 
          x -> do
            warn $ "expecting txn_start, but received " <> bytes (show x)
            return root

instance HasLogger ChainEnv where
  getLogger Config{..} = cfgLogger 

-- blockTime is in milliseconds
instance (MonadIO m, MonadReader Config m, MonadBase IO m) => HasTimer (ChainM m) ChainEvent where
  onTimeout blockTime = stateful Nothing onTimeout'
    where
      onTimeout' Nothing _ = do
        debug "schedule timeout"
        UnixDateTime start <- liftBase $ getCurrentUnixDateTime
        Config{..} <- ask 
        delay <- liftBase $ readRef blockTime
        let t = fromIntegral $ start + fromIntegral delay
        -- Timeout event takes precedence. 
        -- TODO: resource handling for thread ID
        _ <- liftBase $ forkIO $ do
            threadDelay (fromIntegral delay)
            L.debug cfgLogger (L.msg ("deliver timeout" :: String))
            atomically (unGetTQueue cfgArtifactOutbound $ toMessage $ Timeout t)
        return (Just t, Nothing)
      onTimeout' s@(Just t) (Timeout t') | t == t' = do
        debug "reach timeout!"
        return (s, Just ())
      onTimeout' s _ = return (s, Nothing)

newRef :: MonadBase IO m => a -> m (Ref a)
newRef n = liftBase $ do
  x <- newMVar n
  return $ Ref (liftIO $ readMVar x) (liftIO . (\y -> modifyMVar_ x (\_ -> return y)))
