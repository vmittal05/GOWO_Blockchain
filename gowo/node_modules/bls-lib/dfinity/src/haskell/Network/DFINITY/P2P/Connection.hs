{-# LANGUAGE ScopedTypeVariables #-}

module Network.DFINITY.P2P.Connection
   ( connRead
   , connWrite
   , connReadCredentials
   , connWriteCredentials
   , connReadArtifact
   , connWriteArtifact
   , connProcess
   ) where

import Control.Concurrent.STM.TBQueue (TBQueue, writeTBQueue)
import Control.Concurrent.STM.TVar (modifyTVar, readTVar)
import Control.DeepSeq (force)
import Control.Monad (when)
import Control.Monad.STM (atomically)
import Crypto.Hash.SHA256 (hash)
import Data.ByteString.Char8 as Byte (ByteString, empty, length, pack, splitAt, unpack)
import Data.ByteString.Lazy.Char8 (fromStrict)
import Data.ByteString.Short (toShort)
import Data.List (nub)
import Data.LruCache as LRU (insert, lookup)
import Data.Monoid ((<>))
import Data.Word (Word32)
import Network.TLS (Context, contextFlush, recvData, sendData)
import Text.Printf (printf)

import Network.DFINITY.P2P.Types (ArtifactCache, Epoch, NodeId(..), WitnessCache)

-- |
-- Define a byte order.
endianness :: forall a . (Enum a, Integral a) => [a]
endianness = map (256^) [3,2..0::a]

-- |
-- Encode an unsigned 32-bit integer.
encodeWord32 :: Word32 -> ByteString
encodeWord32 n = pack $ map f endianness
   where f = toEnum . fromIntegral . flip mod 256 . div n

-- |
-- Decode an unsigned 32-bit integer.
decodeWord32 :: ByteString -> Maybe Word32
decodeWord32 bs =
   if Byte.length bs /= 4
   then Nothing
   else Just $ sum $ zipWith f endianness $ unpack bs
   where f x = (*x) . fromIntegral . fromEnum

-- |
-- Read data from a connection.
connRead :: Context -> Int -> Maybe ByteString -> IO (ByteString, ByteString)
connRead conn n = \ case
   Nothing -> go 0 empty
   Just bs -> let i = Byte.length bs in go i bs
   where
   go i acc =
      if i >= n
      then pure $ Byte.splitAt n acc
      else do
         chunk <- recvData conn
         let i' = i + Byte.length chunk
         let acc' = acc <> chunk
         i' `seq` acc' `seq` go i' acc'

-- |
-- Write data to a connection.
connWrite :: Context -> ByteString -> IO ()
connWrite conn = sendData conn . fromStrict

-- |
-- Read credentials from a connection.
connReadCredentials :: Context -> Maybe ByteString -> IO (Epoch, NodeId, ByteString)
connReadCredentials conn residue = do
   (decodeWord32 -> Just epoch, residue') <- connRead conn 4 residue
   (NodeId -> nodeId, residue'') <- connRead conn 32 $ Just residue'
   pure (epoch, nodeId, residue'')

-- |
-- Write credentials to a connection.
connWriteCredentials :: Context -> Epoch -> NodeId -> IO ()
connWriteCredentials conn epoch nodeId = do
   connWrite conn $ encodeWord32 epoch
   connWrite conn $ getNodeId nodeId
   contextFlush conn

-- |
-- Read an artifact from a connection.
connReadArtifact :: Context -> Maybe ByteString -> IO (ByteString, ByteString)
connReadArtifact conn residue = do
   (decodeWord32 -> Just size, residue') <- connRead conn 4 residue
   when (size > 5242880) . ioError . userError $
      printf "Cannot receive %d-byte artifact!" size
   let size' = fromIntegral size
   connRead conn size' $ Just residue'

-- |
-- Write an artifact to a connection.
connWriteArtifact :: Context -> ByteString -> IO ()
connWriteArtifact conn artifact = do
   let size = Byte.length artifact
   when (size > 5242880) . ioError . userError $
      printf "Cannot send %d-byte artifact!" size
   let size' = fromIntegral size
   connWrite conn $ encodeWord32 size'
   connWrite conn artifact
   contextFlush conn

-- |
-- Process artifacts from a connection.
connProcess
   :: Context
   -> NodeId
   -> TBQueue (ByteString, NodeId)
   -> ArtifactCache
   -> WitnessCache
   -> Maybe ByteString
   -> IO ()
connProcess conn nodeId receive artifacts witnesses =
   loop where
   loop residue = do
      (artifact, residue') <- connReadArtifact conn residue
      let checksum = toShort $ hash artifact
      atomically $ do
         cache <- readTVar artifacts
         case checksum `seq` LRU.lookup checksum cache of
            Nothing -> do
               let cache' = insert checksum () cache
               cache' `seq` modifyTVar artifacts $ const cache'
               writeTBQueue receive (artifact, nodeId)
            _ -> pure ()
      atomically $ do
         -- TODO: Why not just modify?
         cache <- readTVar witnesses
         let nodeIds = maybe [nodeId] (nub . (nodeId:) . fst) $ LRU.lookup checksum cache
             cache' = force nodeIds `seq` insert checksum nodeIds cache
         cache' `seq` modifyTVar witnesses $ const cache'
      loop $ Just residue'
