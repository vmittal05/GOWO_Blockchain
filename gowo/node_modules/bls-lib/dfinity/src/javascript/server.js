const cbor = require('borc')
const Hypervisor = require('primea-hypervisor')
const EgressDriver = require('primea-hypervisor/egressDriver')
const {ID, Message, decoder: objectDecoder, FunctionRef} = require('primea-objects')
const WasmContainer = require('primea-wasm-container')
const level = require('level-browserify')
const RadixTree = require('dfinity-radix-tree')
const DfinityTx = require('dfinity-tx')

class TestWasmContainer extends WasmContainer {
  constructor (actor) {
    super(actor)
    this._storage = new Map()
    const self = this
    const inter = {
      test: {
        check: (a, b) => {},
        print: (dataRef) => {
          let buf = self.refs.get(dataRef, 'data')
          console.log(buf.toString())
        }
      }
    }
    this.interface = Object.assign(this.interface, inter)
  }
}

const decoder = new cbor.Decoder({
  tags: Object.assign(objectDecoder._knownTags, DfinityTx.getDecoder()._knownTags)
})

const IO_ACTOR_ID = Buffer.from([])

module.exports = class PrimeaServer {
  constructor (opts = {}) {
    const defaults = this.constructor.defaults
    this._opts = Object.assign(defaults, opts)

    const db = level(this._opts.dbPath)
    const rootHash = this._opts.rootHash

    const tree = new RadixTree({
      db: db,
      root: rootHash
    })

    this.egress = new EgressDriver()
    this.hypervisor = new Hypervisor({
      tree,
      containers: this._opts.containers,
      drivers: [this.egress]
    })
    console.log('starting primea')
  }

  ingress (tx) {
    let funcRef, args
    if (tx.actorId.equals(IO_ACTOR_ID)) {
      const actor = this.hypervisor.createActor(this._opts.containers[0].typeId, tx.args[0])
      funcRef = actor.module.getFuncRef(tx.funcName)
      args = tx.args.slice(1)
    } else {
      funcRef = new FunctionRef({
        identifier: [false, tx.funcName],
        params: [],
        actorID: new ID(tx.actorId)
      })
      args = tx.args
    }
    funcRef.gas = tx.ticks

    this.hypervisor.send(new Message({
      funcRef,
      funcArguments: args
    }).on('execution:error', e => console.log(e)))
  }

  async getLink (link) {
    const res = await this.hypervisor.tree.graph._dag.get(link)
    return cbor.encode(res)
  }

  async getNonce (id) {
    id = this._getId(id)
    const node = await this.hypervisor.tree.get(id.id)
    const res = node.value[1]
    return cbor.encode(res)
  }

  async getCode (id) {
    id = this._getId(id)
    const node = await this.hypervisor.tree.get(id.id)
    const res = await this.hypervisor.tree.graph.get(node.node, '1')
    return cbor.encode(res)
  }

  async getStorage (id) {
    id = this._getId(id)
    const node = await this.hypervisor.tree.get(id.id)
    const res = await this.hypervisor.tree.graph.get(node.node, '2')
    return cbor.encode(res)
  }

  async getStateRoot () {
    const res = await this.hypervisor.createStateRoot()
    return res
  }

  async setStateRoot (root) {
    console.log('setStateRoot', root)
    await this.hypervisor.setStateRoot(root)
  }

  _getId (encodedId) {
    if (!(encodedId instanceof ID)) {
      return decoder.decodeFirst(encodedId)
    }
    return encodedId
  }

  static get defaults () {
    return {
      dbPath: './testdb',
      rootHash: 0,
      containers: [TestWasmContainer]
    }
  }
}
